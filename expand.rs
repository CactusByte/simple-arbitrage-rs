#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
mod common {
    use std::sync::Arc;
    use std::time::Duration;
    use ethers::prelude::Provider;
    use ethers::utils::GanacheInstance;
    use ethers::providers::Http;
    pub fn connect(ganache: &GanacheInstance, idx: usize) -> Arc<Provider<Http>> {
        let sender = ganache.addresses()[idx];
        let provider = Provider::<Http>::try_from(ganache.endpoint())
            .unwrap()
            .interval(Duration::from_millis(10u64))
            .with_sender(sender);
        Arc::new(provider)
    }
}
pub use common::*;
#[cfg(test)]
mod simulation_test {
    use super::*;
    use ethers::{prelude::abigen, utils::Ganache};
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker]
    pub const test_arbitrage: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName("simulation_test::test_arbitrage"),
            ignore: false,
            allow_fail: false,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::IntegrationTest,
        },
        testfn: test::StaticTestFn(|| test::assert_test_result(test_arbitrage())),
    };
    fn test_arbitrage() {
        let body = async { pub use uniswapv2router_mod :: * ; # [allow (clippy :: too_many_arguments)] mod uniswapv2router_mod { # ! [allow (clippy :: enum_variant_names)] # ! [allow (dead_code)] # ! [allow (clippy :: type_complexity)] # ! [allow (unused_imports)] # [doc = "UniswapV2Router was auto-generated with ethers-rs Abigen. More information at: https://github.com/gakonst/ethers-rs"] use std :: sync :: Arc ; use ethers :: core :: { abi :: { Abi , Token , Detokenize , InvalidOutputType , Tokenizable } , types :: * } ; use ethers :: contract :: { Contract , builders :: { ContractCall , Event } , Lazy } ; use ethers :: providers :: Middleware ; pub static UNISWAPV2ROUTER_ABI : ethers :: contract :: Lazy < ethers :: core :: abi :: Abi > = ethers :: contract :: Lazy :: new (| | serde_json :: from_str ("[{\"type\":\"constructor\",\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"}]},{\"type\":\"function\",\"name\":\"WETH\",\"inputs\":[],\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"addLiquidity\",\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountADesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"addLiquidityETH\",\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"payable\"},{\"type\":\"function\",\"name\":\"factory\",\"inputs\":[],\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getAmountIn\",\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveOut\",\"type\":\"uint256\"}],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"pure\"},{\"type\":\"function\",\"name\":\"getAmountOut\",\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveOut\",\"type\":\"uint256\"}],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"pure\"},{\"type\":\"function\",\"name\":\"getAmountsIn\",\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getAmountsOut\",\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"quote\",\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveB\",\"type\":\"uint256\"}],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"pure\"},{\"type\":\"function\",\"name\":\"removeLiquidity\",\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"removeLiquidityETH\",\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"removeLiquidityETHSupportingFeeOnTransferTokens\",\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"removeLiquidityETHWithPermit\",\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"removeLiquidityETHWithPermitSupportingFeeOnTransferTokens\",\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"removeLiquidityWithPermit\",\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"swapETHForExactTokens\",\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"constant\":false,\"stateMutability\":\"payable\"},{\"type\":\"function\",\"name\":\"swapExactETHForTokens\",\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"constant\":false,\"stateMutability\":\"payable\"},{\"type\":\"function\",\"name\":\"swapExactETHForTokensSupportingFeeOnTransferTokens\",\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"payable\"},{\"type\":\"function\",\"name\":\"swapExactTokensForETH\",\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"swapExactTokensForETHSupportingFeeOnTransferTokens\",\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"swapExactTokensForTokens\",\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"swapExactTokensForTokensSupportingFeeOnTransferTokens\",\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"swapTokensForExactETH\",\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"swapTokensForExactTokens\",\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"receive\"}]") . expect ("invalid abi")) ; pub struct UniswapV2Router < M > (ethers :: contract :: Contract < M >) ; # [automatically_derived] # [allow (unused_qualifications)] impl < M : :: core :: clone :: Clone > :: core :: clone :: Clone for UniswapV2Router < M > { # [inline] fn clone (& self) -> UniswapV2Router < M > { match * self { UniswapV2Router (ref __self_0_0) => UniswapV2Router (:: core :: clone :: Clone :: clone (& (* __self_0_0))) , } } } impl < M > std :: ops :: Deref for UniswapV2Router < M > { type Target = ethers :: contract :: Contract < M > ; fn deref (& self) -> & Self :: Target { & self . 0 } } impl < M : ethers :: providers :: Middleware > std :: fmt :: Debug for UniswapV2Router < M > { fn fmt (& self , f : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { f . debug_tuple ("UniswapV2Router") . field (& self . address ()) . finish () } } impl < 'a , M : ethers :: providers :: Middleware > UniswapV2Router < M > { # [doc = r" Creates a new contract instance with the specified `ethers`"] # [doc = r" client at the given `Address`. The contract derefs to a `ethers::Contract`"] # [doc = r" object"] pub fn new < T : Into < ethers :: core :: types :: Address > > (address : T , client : :: std :: sync :: Arc < M >) -> Self { let contract = ethers :: contract :: Contract :: new (address . into () , UNISWAPV2ROUTER_ABI . clone () , client) ; Self (contract) } # [doc = "Calls the contract\'s `WETH` (0xad5c4648) function"] pub fn weth (& self) -> ethers :: contract :: builders :: ContractCall < M , ethers :: core :: types :: Address > { self . 0 . method_hash ([173 , 92 , 70 , 72] , ()) . expect ("method not found (this should never happen)") } # [doc = "Calls the contract\'s `addLiquidity` (0xe8e33700) function"] pub fn add_liquidity (& self , token_a : ethers :: core :: types :: Address , token_b : ethers :: core :: types :: Address , amount_a_desired : ethers :: core :: types :: U256 , amount_b_desired : ethers :: core :: types :: U256 , amount_a_min : ethers :: core :: types :: U256 , amount_b_min : ethers :: core :: types :: U256 , to : ethers :: core :: types :: Address , deadline : ethers :: core :: types :: U256) -> ethers :: contract :: builders :: ContractCall < M , (ethers :: core :: types :: U256 , ethers :: core :: types :: U256 , ethers :: core :: types :: U256) > { self . 0 . method_hash ([232 , 227 , 55 , 0] , (token_a , token_b , amount_a_desired , amount_b_desired , amount_a_min , amount_b_min , to , deadline)) . expect ("method not found (this should never happen)") } # [doc = "Calls the contract\'s `addLiquidityETH` (0xf305d719) function"] pub fn add_liquidity_eth (& self , token : ethers :: core :: types :: Address , amount_token_desired : ethers :: core :: types :: U256 , amount_token_min : ethers :: core :: types :: U256 , amount_eth_min : ethers :: core :: types :: U256 , to : ethers :: core :: types :: Address , deadline : ethers :: core :: types :: U256) -> ethers :: contract :: builders :: ContractCall < M , (ethers :: core :: types :: U256 , ethers :: core :: types :: U256 , ethers :: core :: types :: U256) > { self . 0 . method_hash ([243 , 5 , 215 , 25] , (token , amount_token_desired , amount_token_min , amount_eth_min , to , deadline)) . expect ("method not found (this should never happen)") } # [doc = "Calls the contract\'s `factory` (0xc45a0155) function"] pub fn factory (& self) -> ethers :: contract :: builders :: ContractCall < M , ethers :: core :: types :: Address > { self . 0 . method_hash ([196 , 90 , 1 , 85] , ()) . expect ("method not found (this should never happen)") } # [doc = "Calls the contract\'s `getAmountIn` (0x85f8c259) function"] pub fn get_amount_in (& self , amount_out : ethers :: core :: types :: U256 , reserve_in : ethers :: core :: types :: U256 , reserve_out : ethers :: core :: types :: U256) -> ethers :: contract :: builders :: ContractCall < M , ethers :: core :: types :: U256 > { self . 0 . method_hash ([133 , 248 , 194 , 89] , (amount_out , reserve_in , reserve_out)) . expect ("method not found (this should never happen)") } # [doc = "Calls the contract\'s `getAmountOut` (0x054d50d4) function"] pub fn get_amount_out (& self , amount_in : ethers :: core :: types :: U256 , reserve_in : ethers :: core :: types :: U256 , reserve_out : ethers :: core :: types :: U256) -> ethers :: contract :: builders :: ContractCall < M , ethers :: core :: types :: U256 > { self . 0 . method_hash ([5 , 77 , 80 , 212] , (amount_in , reserve_in , reserve_out)) . expect ("method not found (this should never happen)") } # [doc = "Calls the contract\'s `getAmountsIn` (0x1f00ca74) function"] pub fn get_amounts_in (& self , amount_out : ethers :: core :: types :: U256 , path : :: std :: vec :: Vec < ethers :: core :: types :: Address >) -> ethers :: contract :: builders :: ContractCall < M , :: std :: vec :: Vec < ethers :: core :: types :: U256 > > { self . 0 . method_hash ([31 , 0 , 202 , 116] , (amount_out , path)) . expect ("method not found (this should never happen)") } # [doc = "Calls the contract\'s `getAmountsOut` (0xd06ca61f) function"] pub fn get_amounts_out (& self , amount_in : ethers :: core :: types :: U256 , path : :: std :: vec :: Vec < ethers :: core :: types :: Address >) -> ethers :: contract :: builders :: ContractCall < M , :: std :: vec :: Vec < ethers :: core :: types :: U256 > > { self . 0 . method_hash ([208 , 108 , 166 , 31] , (amount_in , path)) . expect ("method not found (this should never happen)") } # [doc = "Calls the contract\'s `quote` (0xad615dec) function"] pub fn quote (& self , amount_a : ethers :: core :: types :: U256 , reserve_a : ethers :: core :: types :: U256 , reserve_b : ethers :: core :: types :: U256) -> ethers :: contract :: builders :: ContractCall < M , ethers :: core :: types :: U256 > { self . 0 . method_hash ([173 , 97 , 93 , 236] , (amount_a , reserve_a , reserve_b)) . expect ("method not found (this should never happen)") } # [doc = "Calls the contract\'s `removeLiquidity` (0xbaa2abde) function"] pub fn remove_liquidity (& self , token_a : ethers :: core :: types :: Address , token_b : ethers :: core :: types :: Address , liquidity : ethers :: core :: types :: U256 , amount_a_min : ethers :: core :: types :: U256 , amount_b_min : ethers :: core :: types :: U256 , to : ethers :: core :: types :: Address , deadline : ethers :: core :: types :: U256) -> ethers :: contract :: builders :: ContractCall < M , (ethers :: core :: types :: U256 , ethers :: core :: types :: U256) > { self . 0 . method_hash ([186 , 162 , 171 , 222] , (token_a , token_b , liquidity , amount_a_min , amount_b_min , to , deadline)) . expect ("method not found (this should never happen)") } # [doc = "Calls the contract\'s `removeLiquidityETH` (0x02751cec) function"] pub fn remove_liquidity_eth (& self , token : ethers :: core :: types :: Address , liquidity : ethers :: core :: types :: U256 , amount_token_min : ethers :: core :: types :: U256 , amount_eth_min : ethers :: core :: types :: U256 , to : ethers :: core :: types :: Address , deadline : ethers :: core :: types :: U256) -> ethers :: contract :: builders :: ContractCall < M , (ethers :: core :: types :: U256 , ethers :: core :: types :: U256) > { self . 0 . method_hash ([2 , 117 , 28 , 236] , (token , liquidity , amount_token_min , amount_eth_min , to , deadline)) . expect ("method not found (this should never happen)") } # [doc = "Calls the contract\'s `removeLiquidityETHSupportingFeeOnTransferTokens` (0xaf2979eb) function"] pub fn remove_liquidity_eth_supporting_fee_on_transfer_tokens (& self , token : ethers :: core :: types :: Address , liquidity : ethers :: core :: types :: U256 , amount_token_min : ethers :: core :: types :: U256 , amount_eth_min : ethers :: core :: types :: U256 , to : ethers :: core :: types :: Address , deadline : ethers :: core :: types :: U256) -> ethers :: contract :: builders :: ContractCall < M , ethers :: core :: types :: U256 > { self . 0 . method_hash ([175 , 41 , 121 , 235] , (token , liquidity , amount_token_min , amount_eth_min , to , deadline)) . expect ("method not found (this should never happen)") } # [doc = "Calls the contract\'s `removeLiquidityETHWithPermit` (0xded9382a) function"] pub fn remove_liquidity_eth_with_permit (& self , token : ethers :: core :: types :: Address , liquidity : ethers :: core :: types :: U256 , amount_token_min : ethers :: core :: types :: U256 , amount_eth_min : ethers :: core :: types :: U256 , to : ethers :: core :: types :: Address , deadline : ethers :: core :: types :: U256 , approve_max : bool , v : u8 , r : [u8 ; 32] , s : [u8 ; 32]) -> ethers :: contract :: builders :: ContractCall < M , (ethers :: core :: types :: U256 , ethers :: core :: types :: U256) > { self . 0 . method_hash ([222 , 217 , 56 , 42] , (token , liquidity , amount_token_min , amount_eth_min , to , deadline , approve_max , v , r , s)) . expect ("method not found (this should never happen)") } # [doc = "Calls the contract\'s `removeLiquidityETHWithPermitSupportingFeeOnTransferTokens` (0x5b0d5984) function"] pub fn remove_liquidity_eth_with_permit_supporting_fee_on_transfer_tokens (& self , token : ethers :: core :: types :: Address , liquidity : ethers :: core :: types :: U256 , amount_token_min : ethers :: core :: types :: U256 , amount_eth_min : ethers :: core :: types :: U256 , to : ethers :: core :: types :: Address , deadline : ethers :: core :: types :: U256 , approve_max : bool , v : u8 , r : [u8 ; 32] , s : [u8 ; 32]) -> ethers :: contract :: builders :: ContractCall < M , ethers :: core :: types :: U256 > { self . 0 . method_hash ([91 , 13 , 89 , 132] , (token , liquidity , amount_token_min , amount_eth_min , to , deadline , approve_max , v , r , s)) . expect ("method not found (this should never happen)") } # [doc = "Calls the contract\'s `removeLiquidityWithPermit` (0x2195995c) function"] pub fn remove_liquidity_with_permit (& self , token_a : ethers :: core :: types :: Address , token_b : ethers :: core :: types :: Address , liquidity : ethers :: core :: types :: U256 , amount_a_min : ethers :: core :: types :: U256 , amount_b_min : ethers :: core :: types :: U256 , to : ethers :: core :: types :: Address , deadline : ethers :: core :: types :: U256 , approve_max : bool , v : u8 , r : [u8 ; 32] , s : [u8 ; 32]) -> ethers :: contract :: builders :: ContractCall < M , (ethers :: core :: types :: U256 , ethers :: core :: types :: U256) > { self . 0 . method_hash ([33 , 149 , 153 , 92] , (token_a , token_b , liquidity , amount_a_min , amount_b_min , to , deadline , approve_max , v , r , s)) . expect ("method not found (this should never happen)") } # [doc = "Calls the contract\'s `swapETHForExactTokens` (0xfb3bdb41) function"] pub fn swap_eth_for_exact_tokens (& self , amount_out : ethers :: core :: types :: U256 , path : :: std :: vec :: Vec < ethers :: core :: types :: Address > , to : ethers :: core :: types :: Address , deadline : ethers :: core :: types :: U256) -> ethers :: contract :: builders :: ContractCall < M , :: std :: vec :: Vec < ethers :: core :: types :: U256 > > { self . 0 . method_hash ([251 , 59 , 219 , 65] , (amount_out , path , to , deadline)) . expect ("method not found (this should never happen)") } # [doc = "Calls the contract\'s `swapExactETHForTokens` (0x7ff36ab5) function"] pub fn swap_exact_eth_for_tokens (& self , amount_out_min : ethers :: core :: types :: U256 , path : :: std :: vec :: Vec < ethers :: core :: types :: Address > , to : ethers :: core :: types :: Address , deadline : ethers :: core :: types :: U256) -> ethers :: contract :: builders :: ContractCall < M , :: std :: vec :: Vec < ethers :: core :: types :: U256 > > { self . 0 . method_hash ([127 , 243 , 106 , 181] , (amount_out_min , path , to , deadline)) . expect ("method not found (this should never happen)") } # [doc = "Calls the contract\'s `swapExactETHForTokensSupportingFeeOnTransferTokens` (0xb6f9de95) function"] pub fn swap_exact_eth_for_tokens_supporting_fee_on_transfer_tokens (& self , amount_out_min : ethers :: core :: types :: U256 , path : :: std :: vec :: Vec < ethers :: core :: types :: Address > , to : ethers :: core :: types :: Address , deadline : ethers :: core :: types :: U256) -> ethers :: contract :: builders :: ContractCall < M , () > { self . 0 . method_hash ([182 , 249 , 222 , 149] , (amount_out_min , path , to , deadline)) . expect ("method not found (this should never happen)") } # [doc = "Calls the contract\'s `swapExactTokensForETH` (0x18cbafe5) function"] pub fn swap_exact_tokens_for_eth (& self , amount_in : ethers :: core :: types :: U256 , amount_out_min : ethers :: core :: types :: U256 , path : :: std :: vec :: Vec < ethers :: core :: types :: Address > , to : ethers :: core :: types :: Address , deadline : ethers :: core :: types :: U256) -> ethers :: contract :: builders :: ContractCall < M , :: std :: vec :: Vec < ethers :: core :: types :: U256 > > { self . 0 . method_hash ([24 , 203 , 175 , 229] , (amount_in , amount_out_min , path , to , deadline)) . expect ("method not found (this should never happen)") } # [doc = "Calls the contract\'s `swapExactTokensForETHSupportingFeeOnTransferTokens` (0x791ac947) function"] pub fn swap_exact_tokens_for_eth_supporting_fee_on_transfer_tokens (& self , amount_in : ethers :: core :: types :: U256 , amount_out_min : ethers :: core :: types :: U256 , path : :: std :: vec :: Vec < ethers :: core :: types :: Address > , to : ethers :: core :: types :: Address , deadline : ethers :: core :: types :: U256) -> ethers :: contract :: builders :: ContractCall < M , () > { self . 0 . method_hash ([121 , 26 , 201 , 71] , (amount_in , amount_out_min , path , to , deadline)) . expect ("method not found (this should never happen)") } # [doc = "Calls the contract\'s `swapExactTokensForTokens` (0x38ed1739) function"] pub fn swap_exact_tokens_for_tokens (& self , amount_in : ethers :: core :: types :: U256 , amount_out_min : ethers :: core :: types :: U256 , path : :: std :: vec :: Vec < ethers :: core :: types :: Address > , to : ethers :: core :: types :: Address , deadline : ethers :: core :: types :: U256) -> ethers :: contract :: builders :: ContractCall < M , :: std :: vec :: Vec < ethers :: core :: types :: U256 > > { self . 0 . method_hash ([56 , 237 , 23 , 57] , (amount_in , amount_out_min , path , to , deadline)) . expect ("method not found (this should never happen)") } # [doc = "Calls the contract\'s `swapExactTokensForTokensSupportingFeeOnTransferTokens` (0x5c11d795) function"] pub fn swap_exact_tokens_for_tokens_supporting_fee_on_transfer_tokens (& self , amount_in : ethers :: core :: types :: U256 , amount_out_min : ethers :: core :: types :: U256 , path : :: std :: vec :: Vec < ethers :: core :: types :: Address > , to : ethers :: core :: types :: Address , deadline : ethers :: core :: types :: U256) -> ethers :: contract :: builders :: ContractCall < M , () > { self . 0 . method_hash ([92 , 17 , 215 , 149] , (amount_in , amount_out_min , path , to , deadline)) . expect ("method not found (this should never happen)") } # [doc = "Calls the contract\'s `swapTokensForExactETH` (0x4a25d94a) function"] pub fn swap_tokens_for_exact_eth (& self , amount_out : ethers :: core :: types :: U256 , amount_in_max : ethers :: core :: types :: U256 , path : :: std :: vec :: Vec < ethers :: core :: types :: Address > , to : ethers :: core :: types :: Address , deadline : ethers :: core :: types :: U256) -> ethers :: contract :: builders :: ContractCall < M , :: std :: vec :: Vec < ethers :: core :: types :: U256 > > { self . 0 . method_hash ([74 , 37 , 217 , 74] , (amount_out , amount_in_max , path , to , deadline)) . expect ("method not found (this should never happen)") } # [doc = "Calls the contract\'s `swapTokensForExactTokens` (0x8803dbee) function"] pub fn swap_tokens_for_exact_tokens (& self , amount_out : ethers :: core :: types :: U256 , amount_in_max : ethers :: core :: types :: U256 , path : :: std :: vec :: Vec < ethers :: core :: types :: Address > , to : ethers :: core :: types :: Address , deadline : ethers :: core :: types :: U256) -> ethers :: contract :: builders :: ContractCall < M , :: std :: vec :: Vec < ethers :: core :: types :: U256 > > { self . 0 . method_hash ([136 , 3 , 219 , 238] , (amount_out , amount_in_max , path , to , deadline)) . expect ("method not found (this should never happen)") } } # [doc = "Container type for all input parameters for the `WETH`function with signature `WETH()` and selector `[173, 92, 70, 72]`"] # [ethcall (name = "WETH" , abi = "WETH()")] pub struct WethCall ; # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for WethCall { # [inline] fn clone (& self) -> WethCall { match * self { WethCall => WethCall , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for WethCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { WethCall => { :: core :: fmt :: Formatter :: write_str (f , "WethCall") } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for WethCall { # [inline] fn default () -> WethCall { WethCall { } } } impl :: core :: marker :: StructuralEq for WethCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for WethCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { } } } impl :: core :: marker :: StructuralPartialEq for WethCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for WethCall { # [inline] fn eq (& self , other : & WethCall) -> bool { match * other { WethCall => match * self { WethCall => true , } , } } } impl ethers :: core :: abi :: Tokenizable for WethCall { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if ! tokens . is_empty () { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected empty tuple, got "] , & match (& tokens ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } else { Ok (WethCall { }) } } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (:: std :: vec :: Vec :: new ()) } } impl ethers :: core :: abi :: TokenizableItem for WethCall { } impl ethers :: contract :: EthCall for WethCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "WETH" . into () } fn selector () -> ethers :: core :: types :: Selector { [173 , 92 , 70 , 72] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "WETH()" . into () } } impl ethers :: core :: abi :: AbiDecode for WethCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for WethCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for WethCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { Ok (()) } } # [doc = "Container type for all input parameters for the `addLiquidity`function with signature `addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)` and selector `[232, 227, 55, 0]`"] # [ethcall (name = "addLiquidity" , abi = "addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)")] pub struct AddLiquidityCall { pub token_a : ethers :: core :: types :: Address , pub token_b : ethers :: core :: types :: Address , pub amount_a_desired : ethers :: core :: types :: U256 , pub amount_b_desired : ethers :: core :: types :: U256 , pub amount_a_min : ethers :: core :: types :: U256 , pub amount_b_min : ethers :: core :: types :: U256 , pub to : ethers :: core :: types :: Address , pub deadline : ethers :: core :: types :: U256 , } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for AddLiquidityCall { # [inline] fn clone (& self) -> AddLiquidityCall { match * self { AddLiquidityCall { token_a : ref __self_0_0 , token_b : ref __self_0_1 , amount_a_desired : ref __self_0_2 , amount_b_desired : ref __self_0_3 , amount_a_min : ref __self_0_4 , amount_b_min : ref __self_0_5 , to : ref __self_0_6 , deadline : ref __self_0_7 } => AddLiquidityCall { token_a : :: core :: clone :: Clone :: clone (& (* __self_0_0)) , token_b : :: core :: clone :: Clone :: clone (& (* __self_0_1)) , amount_a_desired : :: core :: clone :: Clone :: clone (& (* __self_0_2)) , amount_b_desired : :: core :: clone :: Clone :: clone (& (* __self_0_3)) , amount_a_min : :: core :: clone :: Clone :: clone (& (* __self_0_4)) , amount_b_min : :: core :: clone :: Clone :: clone (& (* __self_0_5)) , to : :: core :: clone :: Clone :: clone (& (* __self_0_6)) , deadline : :: core :: clone :: Clone :: clone (& (* __self_0_7)) , } , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for AddLiquidityCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { AddLiquidityCall { token_a : ref __self_0_0 , token_b : ref __self_0_1 , amount_a_desired : ref __self_0_2 , amount_b_desired : ref __self_0_3 , amount_a_min : ref __self_0_4 , amount_b_min : ref __self_0_5 , to : ref __self_0_6 , deadline : ref __self_0_7 } => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_struct (f , "AddLiquidityCall") ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "token_a" , & & (* __self_0_0)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "token_b" , & & (* __self_0_1)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_a_desired" , & & (* __self_0_2)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_b_desired" , & & (* __self_0_3)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_a_min" , & & (* __self_0_4)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_b_min" , & & (* __self_0_5)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "to" , & & (* __self_0_6)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "deadline" , & & (* __self_0_7)) ; :: core :: fmt :: DebugStruct :: finish (debug_trait_builder) } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for AddLiquidityCall { # [inline] fn default () -> AddLiquidityCall { AddLiquidityCall { token_a : :: core :: default :: Default :: default () , token_b : :: core :: default :: Default :: default () , amount_a_desired : :: core :: default :: Default :: default () , amount_b_desired : :: core :: default :: Default :: default () , amount_a_min : :: core :: default :: Default :: default () , amount_b_min : :: core :: default :: Default :: default () , to : :: core :: default :: Default :: default () , deadline : :: core :: default :: Default :: default () , } } } impl :: core :: marker :: StructuralEq for AddLiquidityCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for AddLiquidityCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; } } } impl :: core :: marker :: StructuralPartialEq for AddLiquidityCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for AddLiquidityCall { # [inline] fn eq (& self , other : & AddLiquidityCall) -> bool { match * other { AddLiquidityCall { token_a : ref __self_1_0 , token_b : ref __self_1_1 , amount_a_desired : ref __self_1_2 , amount_b_desired : ref __self_1_3 , amount_a_min : ref __self_1_4 , amount_b_min : ref __self_1_5 , to : ref __self_1_6 , deadline : ref __self_1_7 } => match * self { AddLiquidityCall { token_a : ref __self_0_0 , token_b : ref __self_0_1 , amount_a_desired : ref __self_0_2 , amount_b_desired : ref __self_0_3 , amount_a_min : ref __self_0_4 , amount_b_min : ref __self_0_5 , to : ref __self_0_6 , deadline : ref __self_0_7 } => (* __self_0_0) == (* __self_1_0) && (* __self_0_1) == (* __self_1_1) && (* __self_0_2) == (* __self_1_2) && (* __self_0_3) == (* __self_1_3) && (* __self_0_4) == (* __self_1_4) && (* __self_0_5) == (* __self_1_5) && (* __self_0_6) == (* __self_1_6) && (* __self_0_7) == (* __self_1_7) , } , } } # [inline] fn ne (& self , other : & AddLiquidityCall) -> bool { match * other { AddLiquidityCall { token_a : ref __self_1_0 , token_b : ref __self_1_1 , amount_a_desired : ref __self_1_2 , amount_b_desired : ref __self_1_3 , amount_a_min : ref __self_1_4 , amount_b_min : ref __self_1_5 , to : ref __self_1_6 , deadline : ref __self_1_7 } => match * self { AddLiquidityCall { token_a : ref __self_0_0 , token_b : ref __self_0_1 , amount_a_desired : ref __self_0_2 , amount_b_desired : ref __self_0_3 , amount_a_min : ref __self_0_4 , amount_b_min : ref __self_0_5 , to : ref __self_0_6 , deadline : ref __self_0_7 } => (* __self_0_0) != (* __self_1_0) || (* __self_0_1) != (* __self_1_1) || (* __self_0_2) != (* __self_1_2) || (* __self_0_3) != (* __self_1_3) || (* __self_0_4) != (* __self_1_4) || (* __self_0_5) != (* __self_1_5) || (* __self_0_6) != (* __self_1_6) || (* __self_0_7) != (* __self_1_7) , } , } } } impl ethers :: core :: abi :: AbiType for AddLiquidityCall < > { fn param_type () -> ethers :: core :: abi :: ParamType { ethers :: core :: abi :: ParamType :: Tuple (< [_] > :: into_vec (box [< ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type ()])) } } impl ethers :: core :: abi :: AbiArrayType for AddLiquidityCall < > { } impl ethers :: core :: abi :: Tokenizable for AddLiquidityCall < > where ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if tokens . len () != 8usize { return Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected " , " tokens, got " , ": "] , & match (& 8usize , & tokens . len () , & tokens) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 2 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) ; } let mut iter = tokens . into_iter () ; Ok (Self { token_a : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , token_b : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_a_desired : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_b_desired : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_a_min : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_b_min : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , to : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , deadline : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , }) } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (< [_] > :: into_vec (box [self . token_a . into_token () , self . token_b . into_token () , self . amount_a_desired . into_token () , self . amount_b_desired . into_token () , self . amount_a_min . into_token () , self . amount_b_min . into_token () , self . to . into_token () , self . deadline . into_token ()])) } } impl ethers :: core :: abi :: TokenizableItem for AddLiquidityCall < > where ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { } impl ethers :: contract :: EthCall for AddLiquidityCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "addLiquidity" . into () } fn selector () -> ethers :: core :: types :: Selector { [232 , 227 , 55 , 0] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)" . into () } } impl ethers :: core :: abi :: AbiDecode for AddLiquidityCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize)] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for AddLiquidityCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for AddLiquidityCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . token_a ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . token_b ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_a_desired ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_b_desired ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_a_min ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_b_min ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . to ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . deadline ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; Ok (()) } } # [doc = "Container type for all input parameters for the `addLiquidityETH`function with signature `addLiquidityETH(address,uint256,uint256,uint256,address,uint256)` and selector `[243, 5, 215, 25]`"] # [ethcall (name = "addLiquidityETH" , abi = "addLiquidityETH(address,uint256,uint256,uint256,address,uint256)")] pub struct AddLiquidityETHCall { pub token : ethers :: core :: types :: Address , pub amount_token_desired : ethers :: core :: types :: U256 , pub amount_token_min : ethers :: core :: types :: U256 , pub amount_eth_min : ethers :: core :: types :: U256 , pub to : ethers :: core :: types :: Address , pub deadline : ethers :: core :: types :: U256 , } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for AddLiquidityETHCall { # [inline] fn clone (& self) -> AddLiquidityETHCall { match * self { AddLiquidityETHCall { token : ref __self_0_0 , amount_token_desired : ref __self_0_1 , amount_token_min : ref __self_0_2 , amount_eth_min : ref __self_0_3 , to : ref __self_0_4 , deadline : ref __self_0_5 } => AddLiquidityETHCall { token : :: core :: clone :: Clone :: clone (& (* __self_0_0)) , amount_token_desired : :: core :: clone :: Clone :: clone (& (* __self_0_1)) , amount_token_min : :: core :: clone :: Clone :: clone (& (* __self_0_2)) , amount_eth_min : :: core :: clone :: Clone :: clone (& (* __self_0_3)) , to : :: core :: clone :: Clone :: clone (& (* __self_0_4)) , deadline : :: core :: clone :: Clone :: clone (& (* __self_0_5)) , } , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for AddLiquidityETHCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { AddLiquidityETHCall { token : ref __self_0_0 , amount_token_desired : ref __self_0_1 , amount_token_min : ref __self_0_2 , amount_eth_min : ref __self_0_3 , to : ref __self_0_4 , deadline : ref __self_0_5 } => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_struct (f , "AddLiquidityETHCall") ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "token" , & & (* __self_0_0)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_token_desired" , & & (* __self_0_1)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_token_min" , & & (* __self_0_2)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_eth_min" , & & (* __self_0_3)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "to" , & & (* __self_0_4)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "deadline" , & & (* __self_0_5)) ; :: core :: fmt :: DebugStruct :: finish (debug_trait_builder) } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for AddLiquidityETHCall { # [inline] fn default () -> AddLiquidityETHCall { AddLiquidityETHCall { token : :: core :: default :: Default :: default () , amount_token_desired : :: core :: default :: Default :: default () , amount_token_min : :: core :: default :: Default :: default () , amount_eth_min : :: core :: default :: Default :: default () , to : :: core :: default :: Default :: default () , deadline : :: core :: default :: Default :: default () , } } } impl :: core :: marker :: StructuralEq for AddLiquidityETHCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for AddLiquidityETHCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; } } } impl :: core :: marker :: StructuralPartialEq for AddLiquidityETHCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for AddLiquidityETHCall { # [inline] fn eq (& self , other : & AddLiquidityETHCall) -> bool { match * other { AddLiquidityETHCall { token : ref __self_1_0 , amount_token_desired : ref __self_1_1 , amount_token_min : ref __self_1_2 , amount_eth_min : ref __self_1_3 , to : ref __self_1_4 , deadline : ref __self_1_5 } => match * self { AddLiquidityETHCall { token : ref __self_0_0 , amount_token_desired : ref __self_0_1 , amount_token_min : ref __self_0_2 , amount_eth_min : ref __self_0_3 , to : ref __self_0_4 , deadline : ref __self_0_5 } => (* __self_0_0) == (* __self_1_0) && (* __self_0_1) == (* __self_1_1) && (* __self_0_2) == (* __self_1_2) && (* __self_0_3) == (* __self_1_3) && (* __self_0_4) == (* __self_1_4) && (* __self_0_5) == (* __self_1_5) , } , } } # [inline] fn ne (& self , other : & AddLiquidityETHCall) -> bool { match * other { AddLiquidityETHCall { token : ref __self_1_0 , amount_token_desired : ref __self_1_1 , amount_token_min : ref __self_1_2 , amount_eth_min : ref __self_1_3 , to : ref __self_1_4 , deadline : ref __self_1_5 } => match * self { AddLiquidityETHCall { token : ref __self_0_0 , amount_token_desired : ref __self_0_1 , amount_token_min : ref __self_0_2 , amount_eth_min : ref __self_0_3 , to : ref __self_0_4 , deadline : ref __self_0_5 } => (* __self_0_0) != (* __self_1_0) || (* __self_0_1) != (* __self_1_1) || (* __self_0_2) != (* __self_1_2) || (* __self_0_3) != (* __self_1_3) || (* __self_0_4) != (* __self_1_4) || (* __self_0_5) != (* __self_1_5) , } , } } } impl ethers :: core :: abi :: AbiType for AddLiquidityETHCall < > { fn param_type () -> ethers :: core :: abi :: ParamType { ethers :: core :: abi :: ParamType :: Tuple (< [_] > :: into_vec (box [< ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type ()])) } } impl ethers :: core :: abi :: AbiArrayType for AddLiquidityETHCall < > { } impl ethers :: core :: abi :: Tokenizable for AddLiquidityETHCall < > where ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if tokens . len () != 6usize { return Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected " , " tokens, got " , ": "] , & match (& 6usize , & tokens . len () , & tokens) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 2 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) ; } let mut iter = tokens . into_iter () ; Ok (Self { token : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_token_desired : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_token_min : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_eth_min : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , to : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , deadline : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , }) } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (< [_] > :: into_vec (box [self . token . into_token () , self . amount_token_desired . into_token () , self . amount_token_min . into_token () , self . amount_eth_min . into_token () , self . to . into_token () , self . deadline . into_token ()])) } } impl ethers :: core :: abi :: TokenizableItem for AddLiquidityETHCall < > where ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { } impl ethers :: contract :: EthCall for AddLiquidityETHCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "addLiquidityETH" . into () } fn selector () -> ethers :: core :: types :: Selector { [243 , 5 , 215 , 25] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "addLiquidityETH(address,uint256,uint256,uint256,address,uint256)" . into () } } impl ethers :: core :: abi :: AbiDecode for AddLiquidityETHCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize)] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for AddLiquidityETHCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for AddLiquidityETHCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_token_desired ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_token_min ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_eth_min ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . to ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . deadline ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; Ok (()) } } # [doc = "Container type for all input parameters for the `factory`function with signature `factory()` and selector `[196, 90, 1, 85]`"] # [ethcall (name = "factory" , abi = "factory()")] pub struct FactoryCall ; # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for FactoryCall { # [inline] fn clone (& self) -> FactoryCall { match * self { FactoryCall => FactoryCall , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for FactoryCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { FactoryCall => { :: core :: fmt :: Formatter :: write_str (f , "FactoryCall") } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for FactoryCall { # [inline] fn default () -> FactoryCall { FactoryCall { } } } impl :: core :: marker :: StructuralEq for FactoryCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for FactoryCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { } } } impl :: core :: marker :: StructuralPartialEq for FactoryCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for FactoryCall { # [inline] fn eq (& self , other : & FactoryCall) -> bool { match * other { FactoryCall => match * self { FactoryCall => true , } , } } } impl ethers :: core :: abi :: Tokenizable for FactoryCall { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if ! tokens . is_empty () { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected empty tuple, got "] , & match (& tokens ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } else { Ok (FactoryCall { }) } } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (:: std :: vec :: Vec :: new ()) } } impl ethers :: core :: abi :: TokenizableItem for FactoryCall { } impl ethers :: contract :: EthCall for FactoryCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "factory" . into () } fn selector () -> ethers :: core :: types :: Selector { [196 , 90 , 1 , 85] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "factory()" . into () } } impl ethers :: core :: abi :: AbiDecode for FactoryCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for FactoryCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for FactoryCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { Ok (()) } } # [doc = "Container type for all input parameters for the `getAmountIn`function with signature `getAmountIn(uint256,uint256,uint256)` and selector `[133, 248, 194, 89]`"] # [ethcall (name = "getAmountIn" , abi = "getAmountIn(uint256,uint256,uint256)")] pub struct GetAmountInCall { pub amount_out : ethers :: core :: types :: U256 , pub reserve_in : ethers :: core :: types :: U256 , pub reserve_out : ethers :: core :: types :: U256 , } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for GetAmountInCall { # [inline] fn clone (& self) -> GetAmountInCall { match * self { GetAmountInCall { amount_out : ref __self_0_0 , reserve_in : ref __self_0_1 , reserve_out : ref __self_0_2 } => GetAmountInCall { amount_out : :: core :: clone :: Clone :: clone (& (* __self_0_0)) , reserve_in : :: core :: clone :: Clone :: clone (& (* __self_0_1)) , reserve_out : :: core :: clone :: Clone :: clone (& (* __self_0_2)) , } , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for GetAmountInCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { GetAmountInCall { amount_out : ref __self_0_0 , reserve_in : ref __self_0_1 , reserve_out : ref __self_0_2 } => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_struct (f , "GetAmountInCall") ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_out" , & & (* __self_0_0)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "reserve_in" , & & (* __self_0_1)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "reserve_out" , & & (* __self_0_2)) ; :: core :: fmt :: DebugStruct :: finish (debug_trait_builder) } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for GetAmountInCall { # [inline] fn default () -> GetAmountInCall { GetAmountInCall { amount_out : :: core :: default :: Default :: default () , reserve_in : :: core :: default :: Default :: default () , reserve_out : :: core :: default :: Default :: default () , } } } impl :: core :: marker :: StructuralEq for GetAmountInCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for GetAmountInCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; } } } impl :: core :: marker :: StructuralPartialEq for GetAmountInCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for GetAmountInCall { # [inline] fn eq (& self , other : & GetAmountInCall) -> bool { match * other { GetAmountInCall { amount_out : ref __self_1_0 , reserve_in : ref __self_1_1 , reserve_out : ref __self_1_2 } => match * self { GetAmountInCall { amount_out : ref __self_0_0 , reserve_in : ref __self_0_1 , reserve_out : ref __self_0_2 } => (* __self_0_0) == (* __self_1_0) && (* __self_0_1) == (* __self_1_1) && (* __self_0_2) == (* __self_1_2) , } , } } # [inline] fn ne (& self , other : & GetAmountInCall) -> bool { match * other { GetAmountInCall { amount_out : ref __self_1_0 , reserve_in : ref __self_1_1 , reserve_out : ref __self_1_2 } => match * self { GetAmountInCall { amount_out : ref __self_0_0 , reserve_in : ref __self_0_1 , reserve_out : ref __self_0_2 } => (* __self_0_0) != (* __self_1_0) || (* __self_0_1) != (* __self_1_1) || (* __self_0_2) != (* __self_1_2) , } , } } } impl ethers :: core :: abi :: AbiType for GetAmountInCall < > { fn param_type () -> ethers :: core :: abi :: ParamType { ethers :: core :: abi :: ParamType :: Tuple (< [_] > :: into_vec (box [< ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type ()])) } } impl ethers :: core :: abi :: AbiArrayType for GetAmountInCall < > { } impl ethers :: core :: abi :: Tokenizable for GetAmountInCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if tokens . len () != 3usize { return Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected " , " tokens, got " , ": "] , & match (& 3usize , & tokens . len () , & tokens) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 2 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) ; } let mut iter = tokens . into_iter () ; Ok (Self { amount_out : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , reserve_in : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , reserve_out : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , }) } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (< [_] > :: into_vec (box [self . amount_out . into_token () , self . reserve_in . into_token () , self . reserve_out . into_token ()])) } } impl ethers :: core :: abi :: TokenizableItem for GetAmountInCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { } impl ethers :: contract :: EthCall for GetAmountInCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "getAmountIn" . into () } fn selector () -> ethers :: core :: types :: Selector { [133 , 248 , 194 , 89] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "getAmountIn(uint256,uint256,uint256)" . into () } } impl ethers :: core :: abi :: AbiDecode for GetAmountInCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize)] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for GetAmountInCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for GetAmountInCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_out ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . reserve_in ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . reserve_out ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; Ok (()) } } # [doc = "Container type for all input parameters for the `getAmountOut`function with signature `getAmountOut(uint256,uint256,uint256)` and selector `[5, 77, 80, 212]`"] # [ethcall (name = "getAmountOut" , abi = "getAmountOut(uint256,uint256,uint256)")] pub struct GetAmountOutCall { pub amount_in : ethers :: core :: types :: U256 , pub reserve_in : ethers :: core :: types :: U256 , pub reserve_out : ethers :: core :: types :: U256 , } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for GetAmountOutCall { # [inline] fn clone (& self) -> GetAmountOutCall { match * self { GetAmountOutCall { amount_in : ref __self_0_0 , reserve_in : ref __self_0_1 , reserve_out : ref __self_0_2 } => GetAmountOutCall { amount_in : :: core :: clone :: Clone :: clone (& (* __self_0_0)) , reserve_in : :: core :: clone :: Clone :: clone (& (* __self_0_1)) , reserve_out : :: core :: clone :: Clone :: clone (& (* __self_0_2)) , } , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for GetAmountOutCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { GetAmountOutCall { amount_in : ref __self_0_0 , reserve_in : ref __self_0_1 , reserve_out : ref __self_0_2 } => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_struct (f , "GetAmountOutCall") ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_in" , & & (* __self_0_0)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "reserve_in" , & & (* __self_0_1)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "reserve_out" , & & (* __self_0_2)) ; :: core :: fmt :: DebugStruct :: finish (debug_trait_builder) } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for GetAmountOutCall { # [inline] fn default () -> GetAmountOutCall { GetAmountOutCall { amount_in : :: core :: default :: Default :: default () , reserve_in : :: core :: default :: Default :: default () , reserve_out : :: core :: default :: Default :: default () , } } } impl :: core :: marker :: StructuralEq for GetAmountOutCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for GetAmountOutCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; } } } impl :: core :: marker :: StructuralPartialEq for GetAmountOutCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for GetAmountOutCall { # [inline] fn eq (& self , other : & GetAmountOutCall) -> bool { match * other { GetAmountOutCall { amount_in : ref __self_1_0 , reserve_in : ref __self_1_1 , reserve_out : ref __self_1_2 } => match * self { GetAmountOutCall { amount_in : ref __self_0_0 , reserve_in : ref __self_0_1 , reserve_out : ref __self_0_2 } => (* __self_0_0) == (* __self_1_0) && (* __self_0_1) == (* __self_1_1) && (* __self_0_2) == (* __self_1_2) , } , } } # [inline] fn ne (& self , other : & GetAmountOutCall) -> bool { match * other { GetAmountOutCall { amount_in : ref __self_1_0 , reserve_in : ref __self_1_1 , reserve_out : ref __self_1_2 } => match * self { GetAmountOutCall { amount_in : ref __self_0_0 , reserve_in : ref __self_0_1 , reserve_out : ref __self_0_2 } => (* __self_0_0) != (* __self_1_0) || (* __self_0_1) != (* __self_1_1) || (* __self_0_2) != (* __self_1_2) , } , } } } impl ethers :: core :: abi :: AbiType for GetAmountOutCall < > { fn param_type () -> ethers :: core :: abi :: ParamType { ethers :: core :: abi :: ParamType :: Tuple (< [_] > :: into_vec (box [< ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type ()])) } } impl ethers :: core :: abi :: AbiArrayType for GetAmountOutCall < > { } impl ethers :: core :: abi :: Tokenizable for GetAmountOutCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if tokens . len () != 3usize { return Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected " , " tokens, got " , ": "] , & match (& 3usize , & tokens . len () , & tokens) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 2 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) ; } let mut iter = tokens . into_iter () ; Ok (Self { amount_in : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , reserve_in : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , reserve_out : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , }) } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (< [_] > :: into_vec (box [self . amount_in . into_token () , self . reserve_in . into_token () , self . reserve_out . into_token ()])) } } impl ethers :: core :: abi :: TokenizableItem for GetAmountOutCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { } impl ethers :: contract :: EthCall for GetAmountOutCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "getAmountOut" . into () } fn selector () -> ethers :: core :: types :: Selector { [5 , 77 , 80 , 212] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "getAmountOut(uint256,uint256,uint256)" . into () } } impl ethers :: core :: abi :: AbiDecode for GetAmountOutCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize)] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for GetAmountOutCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for GetAmountOutCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_in ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . reserve_in ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . reserve_out ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; Ok (()) } } # [doc = "Container type for all input parameters for the `getAmountsIn`function with signature `getAmountsIn(uint256,address[])` and selector `[31, 0, 202, 116]`"] # [ethcall (name = "getAmountsIn" , abi = "getAmountsIn(uint256,address[])")] pub struct GetAmountsInCall { pub amount_out : ethers :: core :: types :: U256 , pub path : :: std :: vec :: Vec < ethers :: core :: types :: Address > , } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for GetAmountsInCall { # [inline] fn clone (& self) -> GetAmountsInCall { match * self { GetAmountsInCall { amount_out : ref __self_0_0 , path : ref __self_0_1 } => GetAmountsInCall { amount_out : :: core :: clone :: Clone :: clone (& (* __self_0_0)) , path : :: core :: clone :: Clone :: clone (& (* __self_0_1)) , } , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for GetAmountsInCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { GetAmountsInCall { amount_out : ref __self_0_0 , path : ref __self_0_1 } => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_struct (f , "GetAmountsInCall") ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_out" , & & (* __self_0_0)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "path" , & & (* __self_0_1)) ; :: core :: fmt :: DebugStruct :: finish (debug_trait_builder) } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for GetAmountsInCall { # [inline] fn default () -> GetAmountsInCall { GetAmountsInCall { amount_out : :: core :: default :: Default :: default () , path : :: core :: default :: Default :: default () , } } } impl :: core :: marker :: StructuralEq for GetAmountsInCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for GetAmountsInCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < :: std :: vec :: Vec < ethers :: core :: types :: Address > > ; } } } impl :: core :: marker :: StructuralPartialEq for GetAmountsInCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for GetAmountsInCall { # [inline] fn eq (& self , other : & GetAmountsInCall) -> bool { match * other { GetAmountsInCall { amount_out : ref __self_1_0 , path : ref __self_1_1 } => match * self { GetAmountsInCall { amount_out : ref __self_0_0 , path : ref __self_0_1 } => (* __self_0_0) == (* __self_1_0) && (* __self_0_1) == (* __self_1_1) , } , } } # [inline] fn ne (& self , other : & GetAmountsInCall) -> bool { match * other { GetAmountsInCall { amount_out : ref __self_1_0 , path : ref __self_1_1 } => match * self { GetAmountsInCall { amount_out : ref __self_0_0 , path : ref __self_0_1 } => (* __self_0_0) != (* __self_1_0) || (* __self_0_1) != (* __self_1_1) , } , } } } impl ethers :: core :: abi :: AbiType for GetAmountsInCall < > { fn param_type () -> ethers :: core :: abi :: ParamType { ethers :: core :: abi :: ParamType :: Tuple (< [_] > :: into_vec (box [< ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < :: std :: vec :: Vec < ethers :: core :: types :: Address > as ethers :: core :: abi :: AbiType > :: param_type ()])) } } impl ethers :: core :: abi :: AbiArrayType for GetAmountsInCall < > { } impl ethers :: core :: abi :: Tokenizable for GetAmountsInCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , :: std :: vec :: Vec < ethers :: core :: types :: Address > : ethers :: core :: abi :: Tokenize { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if tokens . len () != 2usize { return Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected " , " tokens, got " , ": "] , & match (& 2usize , & tokens . len () , & tokens) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 2 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) ; } let mut iter = tokens . into_iter () ; Ok (Self { amount_out : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , path : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , }) } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (< [_] > :: into_vec (box [self . amount_out . into_token () , self . path . into_token ()])) } } impl ethers :: core :: abi :: TokenizableItem for GetAmountsInCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , :: std :: vec :: Vec < ethers :: core :: types :: Address > : ethers :: core :: abi :: Tokenize { } impl ethers :: contract :: EthCall for GetAmountsInCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "getAmountsIn" . into () } fn selector () -> ethers :: core :: types :: Selector { [31 , 0 , 202 , 116] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "getAmountsIn(uint256,address[])" . into () } } impl ethers :: core :: abi :: AbiDecode for GetAmountsInCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Array (Box :: new (ethers :: core :: abi :: ParamType :: Address))] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for GetAmountsInCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for GetAmountsInCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_out ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . path ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; Ok (()) } } # [doc = "Container type for all input parameters for the `getAmountsOut`function with signature `getAmountsOut(uint256,address[])` and selector `[208, 108, 166, 31]`"] # [ethcall (name = "getAmountsOut" , abi = "getAmountsOut(uint256,address[])")] pub struct GetAmountsOutCall { pub amount_in : ethers :: core :: types :: U256 , pub path : :: std :: vec :: Vec < ethers :: core :: types :: Address > , } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for GetAmountsOutCall { # [inline] fn clone (& self) -> GetAmountsOutCall { match * self { GetAmountsOutCall { amount_in : ref __self_0_0 , path : ref __self_0_1 } => GetAmountsOutCall { amount_in : :: core :: clone :: Clone :: clone (& (* __self_0_0)) , path : :: core :: clone :: Clone :: clone (& (* __self_0_1)) , } , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for GetAmountsOutCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { GetAmountsOutCall { amount_in : ref __self_0_0 , path : ref __self_0_1 } => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_struct (f , "GetAmountsOutCall") ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_in" , & & (* __self_0_0)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "path" , & & (* __self_0_1)) ; :: core :: fmt :: DebugStruct :: finish (debug_trait_builder) } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for GetAmountsOutCall { # [inline] fn default () -> GetAmountsOutCall { GetAmountsOutCall { amount_in : :: core :: default :: Default :: default () , path : :: core :: default :: Default :: default () , } } } impl :: core :: marker :: StructuralEq for GetAmountsOutCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for GetAmountsOutCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < :: std :: vec :: Vec < ethers :: core :: types :: Address > > ; } } } impl :: core :: marker :: StructuralPartialEq for GetAmountsOutCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for GetAmountsOutCall { # [inline] fn eq (& self , other : & GetAmountsOutCall) -> bool { match * other { GetAmountsOutCall { amount_in : ref __self_1_0 , path : ref __self_1_1 } => match * self { GetAmountsOutCall { amount_in : ref __self_0_0 , path : ref __self_0_1 } => (* __self_0_0) == (* __self_1_0) && (* __self_0_1) == (* __self_1_1) , } , } } # [inline] fn ne (& self , other : & GetAmountsOutCall) -> bool { match * other { GetAmountsOutCall { amount_in : ref __self_1_0 , path : ref __self_1_1 } => match * self { GetAmountsOutCall { amount_in : ref __self_0_0 , path : ref __self_0_1 } => (* __self_0_0) != (* __self_1_0) || (* __self_0_1) != (* __self_1_1) , } , } } } impl ethers :: core :: abi :: AbiType for GetAmountsOutCall < > { fn param_type () -> ethers :: core :: abi :: ParamType { ethers :: core :: abi :: ParamType :: Tuple (< [_] > :: into_vec (box [< ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < :: std :: vec :: Vec < ethers :: core :: types :: Address > as ethers :: core :: abi :: AbiType > :: param_type ()])) } } impl ethers :: core :: abi :: AbiArrayType for GetAmountsOutCall < > { } impl ethers :: core :: abi :: Tokenizable for GetAmountsOutCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , :: std :: vec :: Vec < ethers :: core :: types :: Address > : ethers :: core :: abi :: Tokenize { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if tokens . len () != 2usize { return Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected " , " tokens, got " , ": "] , & match (& 2usize , & tokens . len () , & tokens) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 2 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) ; } let mut iter = tokens . into_iter () ; Ok (Self { amount_in : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , path : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , }) } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (< [_] > :: into_vec (box [self . amount_in . into_token () , self . path . into_token ()])) } } impl ethers :: core :: abi :: TokenizableItem for GetAmountsOutCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , :: std :: vec :: Vec < ethers :: core :: types :: Address > : ethers :: core :: abi :: Tokenize { } impl ethers :: contract :: EthCall for GetAmountsOutCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "getAmountsOut" . into () } fn selector () -> ethers :: core :: types :: Selector { [208 , 108 , 166 , 31] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "getAmountsOut(uint256,address[])" . into () } } impl ethers :: core :: abi :: AbiDecode for GetAmountsOutCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Array (Box :: new (ethers :: core :: abi :: ParamType :: Address))] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for GetAmountsOutCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for GetAmountsOutCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_in ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . path ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; Ok (()) } } # [doc = "Container type for all input parameters for the `quote`function with signature `quote(uint256,uint256,uint256)` and selector `[173, 97, 93, 236]`"] # [ethcall (name = "quote" , abi = "quote(uint256,uint256,uint256)")] pub struct QuoteCall { pub amount_a : ethers :: core :: types :: U256 , pub reserve_a : ethers :: core :: types :: U256 , pub reserve_b : ethers :: core :: types :: U256 , } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for QuoteCall { # [inline] fn clone (& self) -> QuoteCall { match * self { QuoteCall { amount_a : ref __self_0_0 , reserve_a : ref __self_0_1 , reserve_b : ref __self_0_2 } => QuoteCall { amount_a : :: core :: clone :: Clone :: clone (& (* __self_0_0)) , reserve_a : :: core :: clone :: Clone :: clone (& (* __self_0_1)) , reserve_b : :: core :: clone :: Clone :: clone (& (* __self_0_2)) , } , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for QuoteCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { QuoteCall { amount_a : ref __self_0_0 , reserve_a : ref __self_0_1 , reserve_b : ref __self_0_2 } => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_struct (f , "QuoteCall") ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_a" , & & (* __self_0_0)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "reserve_a" , & & (* __self_0_1)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "reserve_b" , & & (* __self_0_2)) ; :: core :: fmt :: DebugStruct :: finish (debug_trait_builder) } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for QuoteCall { # [inline] fn default () -> QuoteCall { QuoteCall { amount_a : :: core :: default :: Default :: default () , reserve_a : :: core :: default :: Default :: default () , reserve_b : :: core :: default :: Default :: default () , } } } impl :: core :: marker :: StructuralEq for QuoteCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for QuoteCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; } } } impl :: core :: marker :: StructuralPartialEq for QuoteCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for QuoteCall { # [inline] fn eq (& self , other : & QuoteCall) -> bool { match * other { QuoteCall { amount_a : ref __self_1_0 , reserve_a : ref __self_1_1 , reserve_b : ref __self_1_2 } => match * self { QuoteCall { amount_a : ref __self_0_0 , reserve_a : ref __self_0_1 , reserve_b : ref __self_0_2 } => (* __self_0_0) == (* __self_1_0) && (* __self_0_1) == (* __self_1_1) && (* __self_0_2) == (* __self_1_2) , } , } } # [inline] fn ne (& self , other : & QuoteCall) -> bool { match * other { QuoteCall { amount_a : ref __self_1_0 , reserve_a : ref __self_1_1 , reserve_b : ref __self_1_2 } => match * self { QuoteCall { amount_a : ref __self_0_0 , reserve_a : ref __self_0_1 , reserve_b : ref __self_0_2 } => (* __self_0_0) != (* __self_1_0) || (* __self_0_1) != (* __self_1_1) || (* __self_0_2) != (* __self_1_2) , } , } } } impl ethers :: core :: abi :: AbiType for QuoteCall < > { fn param_type () -> ethers :: core :: abi :: ParamType { ethers :: core :: abi :: ParamType :: Tuple (< [_] > :: into_vec (box [< ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type ()])) } } impl ethers :: core :: abi :: AbiArrayType for QuoteCall < > { } impl ethers :: core :: abi :: Tokenizable for QuoteCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if tokens . len () != 3usize { return Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected " , " tokens, got " , ": "] , & match (& 3usize , & tokens . len () , & tokens) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 2 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) ; } let mut iter = tokens . into_iter () ; Ok (Self { amount_a : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , reserve_a : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , reserve_b : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , }) } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (< [_] > :: into_vec (box [self . amount_a . into_token () , self . reserve_a . into_token () , self . reserve_b . into_token ()])) } } impl ethers :: core :: abi :: TokenizableItem for QuoteCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { } impl ethers :: contract :: EthCall for QuoteCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "quote" . into () } fn selector () -> ethers :: core :: types :: Selector { [173 , 97 , 93 , 236] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "quote(uint256,uint256,uint256)" . into () } } impl ethers :: core :: abi :: AbiDecode for QuoteCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize)] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for QuoteCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for QuoteCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_a ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . reserve_a ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . reserve_b ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; Ok (()) } } # [doc = "Container type for all input parameters for the `removeLiquidity`function with signature `removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)` and selector `[186, 162, 171, 222]`"] # [ethcall (name = "removeLiquidity" , abi = "removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)")] pub struct RemoveLiquidityCall { pub token_a : ethers :: core :: types :: Address , pub token_b : ethers :: core :: types :: Address , pub liquidity : ethers :: core :: types :: U256 , pub amount_a_min : ethers :: core :: types :: U256 , pub amount_b_min : ethers :: core :: types :: U256 , pub to : ethers :: core :: types :: Address , pub deadline : ethers :: core :: types :: U256 , } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for RemoveLiquidityCall { # [inline] fn clone (& self) -> RemoveLiquidityCall { match * self { RemoveLiquidityCall { token_a : ref __self_0_0 , token_b : ref __self_0_1 , liquidity : ref __self_0_2 , amount_a_min : ref __self_0_3 , amount_b_min : ref __self_0_4 , to : ref __self_0_5 , deadline : ref __self_0_6 } => RemoveLiquidityCall { token_a : :: core :: clone :: Clone :: clone (& (* __self_0_0)) , token_b : :: core :: clone :: Clone :: clone (& (* __self_0_1)) , liquidity : :: core :: clone :: Clone :: clone (& (* __self_0_2)) , amount_a_min : :: core :: clone :: Clone :: clone (& (* __self_0_3)) , amount_b_min : :: core :: clone :: Clone :: clone (& (* __self_0_4)) , to : :: core :: clone :: Clone :: clone (& (* __self_0_5)) , deadline : :: core :: clone :: Clone :: clone (& (* __self_0_6)) , } , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for RemoveLiquidityCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { RemoveLiquidityCall { token_a : ref __self_0_0 , token_b : ref __self_0_1 , liquidity : ref __self_0_2 , amount_a_min : ref __self_0_3 , amount_b_min : ref __self_0_4 , to : ref __self_0_5 , deadline : ref __self_0_6 } => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_struct (f , "RemoveLiquidityCall") ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "token_a" , & & (* __self_0_0)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "token_b" , & & (* __self_0_1)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "liquidity" , & & (* __self_0_2)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_a_min" , & & (* __self_0_3)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_b_min" , & & (* __self_0_4)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "to" , & & (* __self_0_5)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "deadline" , & & (* __self_0_6)) ; :: core :: fmt :: DebugStruct :: finish (debug_trait_builder) } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for RemoveLiquidityCall { # [inline] fn default () -> RemoveLiquidityCall { RemoveLiquidityCall { token_a : :: core :: default :: Default :: default () , token_b : :: core :: default :: Default :: default () , liquidity : :: core :: default :: Default :: default () , amount_a_min : :: core :: default :: Default :: default () , amount_b_min : :: core :: default :: Default :: default () , to : :: core :: default :: Default :: default () , deadline : :: core :: default :: Default :: default () , } } } impl :: core :: marker :: StructuralEq for RemoveLiquidityCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for RemoveLiquidityCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; } } } impl :: core :: marker :: StructuralPartialEq for RemoveLiquidityCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for RemoveLiquidityCall { # [inline] fn eq (& self , other : & RemoveLiquidityCall) -> bool { match * other { RemoveLiquidityCall { token_a : ref __self_1_0 , token_b : ref __self_1_1 , liquidity : ref __self_1_2 , amount_a_min : ref __self_1_3 , amount_b_min : ref __self_1_4 , to : ref __self_1_5 , deadline : ref __self_1_6 } => match * self { RemoveLiquidityCall { token_a : ref __self_0_0 , token_b : ref __self_0_1 , liquidity : ref __self_0_2 , amount_a_min : ref __self_0_3 , amount_b_min : ref __self_0_4 , to : ref __self_0_5 , deadline : ref __self_0_6 } => (* __self_0_0) == (* __self_1_0) && (* __self_0_1) == (* __self_1_1) && (* __self_0_2) == (* __self_1_2) && (* __self_0_3) == (* __self_1_3) && (* __self_0_4) == (* __self_1_4) && (* __self_0_5) == (* __self_1_5) && (* __self_0_6) == (* __self_1_6) , } , } } # [inline] fn ne (& self , other : & RemoveLiquidityCall) -> bool { match * other { RemoveLiquidityCall { token_a : ref __self_1_0 , token_b : ref __self_1_1 , liquidity : ref __self_1_2 , amount_a_min : ref __self_1_3 , amount_b_min : ref __self_1_4 , to : ref __self_1_5 , deadline : ref __self_1_6 } => match * self { RemoveLiquidityCall { token_a : ref __self_0_0 , token_b : ref __self_0_1 , liquidity : ref __self_0_2 , amount_a_min : ref __self_0_3 , amount_b_min : ref __self_0_4 , to : ref __self_0_5 , deadline : ref __self_0_6 } => (* __self_0_0) != (* __self_1_0) || (* __self_0_1) != (* __self_1_1) || (* __self_0_2) != (* __self_1_2) || (* __self_0_3) != (* __self_1_3) || (* __self_0_4) != (* __self_1_4) || (* __self_0_5) != (* __self_1_5) || (* __self_0_6) != (* __self_1_6) , } , } } } impl ethers :: core :: abi :: AbiType for RemoveLiquidityCall < > { fn param_type () -> ethers :: core :: abi :: ParamType { ethers :: core :: abi :: ParamType :: Tuple (< [_] > :: into_vec (box [< ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type ()])) } } impl ethers :: core :: abi :: AbiArrayType for RemoveLiquidityCall < > { } impl ethers :: core :: abi :: Tokenizable for RemoveLiquidityCall < > where ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if tokens . len () != 7usize { return Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected " , " tokens, got " , ": "] , & match (& 7usize , & tokens . len () , & tokens) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 2 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) ; } let mut iter = tokens . into_iter () ; Ok (Self { token_a : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , token_b : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , liquidity : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_a_min : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_b_min : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , to : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , deadline : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , }) } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (< [_] > :: into_vec (box [self . token_a . into_token () , self . token_b . into_token () , self . liquidity . into_token () , self . amount_a_min . into_token () , self . amount_b_min . into_token () , self . to . into_token () , self . deadline . into_token ()])) } } impl ethers :: core :: abi :: TokenizableItem for RemoveLiquidityCall < > where ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { } impl ethers :: contract :: EthCall for RemoveLiquidityCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "removeLiquidity" . into () } fn selector () -> ethers :: core :: types :: Selector { [186 , 162 , 171 , 222] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)" . into () } } impl ethers :: core :: abi :: AbiDecode for RemoveLiquidityCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize)] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for RemoveLiquidityCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for RemoveLiquidityCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . token_a ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . token_b ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . liquidity ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_a_min ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_b_min ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . to ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . deadline ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; Ok (()) } } # [doc = "Container type for all input parameters for the `removeLiquidityETH`function with signature `removeLiquidityETH(address,uint256,uint256,uint256,address,uint256)` and selector `[2, 117, 28, 236]`"] # [ethcall (name = "removeLiquidityETH" , abi = "removeLiquidityETH(address,uint256,uint256,uint256,address,uint256)")] pub struct RemoveLiquidityETHCall { pub token : ethers :: core :: types :: Address , pub liquidity : ethers :: core :: types :: U256 , pub amount_token_min : ethers :: core :: types :: U256 , pub amount_eth_min : ethers :: core :: types :: U256 , pub to : ethers :: core :: types :: Address , pub deadline : ethers :: core :: types :: U256 , } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for RemoveLiquidityETHCall { # [inline] fn clone (& self) -> RemoveLiquidityETHCall { match * self { RemoveLiquidityETHCall { token : ref __self_0_0 , liquidity : ref __self_0_1 , amount_token_min : ref __self_0_2 , amount_eth_min : ref __self_0_3 , to : ref __self_0_4 , deadline : ref __self_0_5 } => RemoveLiquidityETHCall { token : :: core :: clone :: Clone :: clone (& (* __self_0_0)) , liquidity : :: core :: clone :: Clone :: clone (& (* __self_0_1)) , amount_token_min : :: core :: clone :: Clone :: clone (& (* __self_0_2)) , amount_eth_min : :: core :: clone :: Clone :: clone (& (* __self_0_3)) , to : :: core :: clone :: Clone :: clone (& (* __self_0_4)) , deadline : :: core :: clone :: Clone :: clone (& (* __self_0_5)) , } , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for RemoveLiquidityETHCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { RemoveLiquidityETHCall { token : ref __self_0_0 , liquidity : ref __self_0_1 , amount_token_min : ref __self_0_2 , amount_eth_min : ref __self_0_3 , to : ref __self_0_4 , deadline : ref __self_0_5 } => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_struct (f , "RemoveLiquidityETHCall") ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "token" , & & (* __self_0_0)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "liquidity" , & & (* __self_0_1)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_token_min" , & & (* __self_0_2)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_eth_min" , & & (* __self_0_3)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "to" , & & (* __self_0_4)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "deadline" , & & (* __self_0_5)) ; :: core :: fmt :: DebugStruct :: finish (debug_trait_builder) } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for RemoveLiquidityETHCall { # [inline] fn default () -> RemoveLiquidityETHCall { RemoveLiquidityETHCall { token : :: core :: default :: Default :: default () , liquidity : :: core :: default :: Default :: default () , amount_token_min : :: core :: default :: Default :: default () , amount_eth_min : :: core :: default :: Default :: default () , to : :: core :: default :: Default :: default () , deadline : :: core :: default :: Default :: default () , } } } impl :: core :: marker :: StructuralEq for RemoveLiquidityETHCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for RemoveLiquidityETHCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; } } } impl :: core :: marker :: StructuralPartialEq for RemoveLiquidityETHCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for RemoveLiquidityETHCall { # [inline] fn eq (& self , other : & RemoveLiquidityETHCall) -> bool { match * other { RemoveLiquidityETHCall { token : ref __self_1_0 , liquidity : ref __self_1_1 , amount_token_min : ref __self_1_2 , amount_eth_min : ref __self_1_3 , to : ref __self_1_4 , deadline : ref __self_1_5 } => match * self { RemoveLiquidityETHCall { token : ref __self_0_0 , liquidity : ref __self_0_1 , amount_token_min : ref __self_0_2 , amount_eth_min : ref __self_0_3 , to : ref __self_0_4 , deadline : ref __self_0_5 } => (* __self_0_0) == (* __self_1_0) && (* __self_0_1) == (* __self_1_1) && (* __self_0_2) == (* __self_1_2) && (* __self_0_3) == (* __self_1_3) && (* __self_0_4) == (* __self_1_4) && (* __self_0_5) == (* __self_1_5) , } , } } # [inline] fn ne (& self , other : & RemoveLiquidityETHCall) -> bool { match * other { RemoveLiquidityETHCall { token : ref __self_1_0 , liquidity : ref __self_1_1 , amount_token_min : ref __self_1_2 , amount_eth_min : ref __self_1_3 , to : ref __self_1_4 , deadline : ref __self_1_5 } => match * self { RemoveLiquidityETHCall { token : ref __self_0_0 , liquidity : ref __self_0_1 , amount_token_min : ref __self_0_2 , amount_eth_min : ref __self_0_3 , to : ref __self_0_4 , deadline : ref __self_0_5 } => (* __self_0_0) != (* __self_1_0) || (* __self_0_1) != (* __self_1_1) || (* __self_0_2) != (* __self_1_2) || (* __self_0_3) != (* __self_1_3) || (* __self_0_4) != (* __self_1_4) || (* __self_0_5) != (* __self_1_5) , } , } } } impl ethers :: core :: abi :: AbiType for RemoveLiquidityETHCall < > { fn param_type () -> ethers :: core :: abi :: ParamType { ethers :: core :: abi :: ParamType :: Tuple (< [_] > :: into_vec (box [< ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type ()])) } } impl ethers :: core :: abi :: AbiArrayType for RemoveLiquidityETHCall < > { } impl ethers :: core :: abi :: Tokenizable for RemoveLiquidityETHCall < > where ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if tokens . len () != 6usize { return Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected " , " tokens, got " , ": "] , & match (& 6usize , & tokens . len () , & tokens) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 2 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) ; } let mut iter = tokens . into_iter () ; Ok (Self { token : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , liquidity : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_token_min : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_eth_min : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , to : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , deadline : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , }) } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (< [_] > :: into_vec (box [self . token . into_token () , self . liquidity . into_token () , self . amount_token_min . into_token () , self . amount_eth_min . into_token () , self . to . into_token () , self . deadline . into_token ()])) } } impl ethers :: core :: abi :: TokenizableItem for RemoveLiquidityETHCall < > where ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { } impl ethers :: contract :: EthCall for RemoveLiquidityETHCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "removeLiquidityETH" . into () } fn selector () -> ethers :: core :: types :: Selector { [2 , 117 , 28 , 236] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "removeLiquidityETH(address,uint256,uint256,uint256,address,uint256)" . into () } } impl ethers :: core :: abi :: AbiDecode for RemoveLiquidityETHCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize)] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for RemoveLiquidityETHCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for RemoveLiquidityETHCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . liquidity ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_token_min ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_eth_min ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . to ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . deadline ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; Ok (()) } } # [doc = "Container type for all input parameters for the `removeLiquidityETHSupportingFeeOnTransferTokens`function with signature `removeLiquidityETHSupportingFeeOnTransferTokens(address,uint256,uint256,uint256,address,uint256)` and selector `[175, 41, 121, 235]`"] # [ethcall (name = "removeLiquidityETHSupportingFeeOnTransferTokens" , abi = "removeLiquidityETHSupportingFeeOnTransferTokens(address,uint256,uint256,uint256,address,uint256)")] pub struct RemoveLiquidityETHSupportingFeeOnTransferTokensCall { pub token : ethers :: core :: types :: Address , pub liquidity : ethers :: core :: types :: U256 , pub amount_token_min : ethers :: core :: types :: U256 , pub amount_eth_min : ethers :: core :: types :: U256 , pub to : ethers :: core :: types :: Address , pub deadline : ethers :: core :: types :: U256 , } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for RemoveLiquidityETHSupportingFeeOnTransferTokensCall { # [inline] fn clone (& self) -> RemoveLiquidityETHSupportingFeeOnTransferTokensCall { match * self { RemoveLiquidityETHSupportingFeeOnTransferTokensCall { token : ref __self_0_0 , liquidity : ref __self_0_1 , amount_token_min : ref __self_0_2 , amount_eth_min : ref __self_0_3 , to : ref __self_0_4 , deadline : ref __self_0_5 } => RemoveLiquidityETHSupportingFeeOnTransferTokensCall { token : :: core :: clone :: Clone :: clone (& (* __self_0_0)) , liquidity : :: core :: clone :: Clone :: clone (& (* __self_0_1)) , amount_token_min : :: core :: clone :: Clone :: clone (& (* __self_0_2)) , amount_eth_min : :: core :: clone :: Clone :: clone (& (* __self_0_3)) , to : :: core :: clone :: Clone :: clone (& (* __self_0_4)) , deadline : :: core :: clone :: Clone :: clone (& (* __self_0_5)) , } , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for RemoveLiquidityETHSupportingFeeOnTransferTokensCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { RemoveLiquidityETHSupportingFeeOnTransferTokensCall { token : ref __self_0_0 , liquidity : ref __self_0_1 , amount_token_min : ref __self_0_2 , amount_eth_min : ref __self_0_3 , to : ref __self_0_4 , deadline : ref __self_0_5 } => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_struct (f , "RemoveLiquidityETHSupportingFeeOnTransferTokensCall") ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "token" , & & (* __self_0_0)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "liquidity" , & & (* __self_0_1)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_token_min" , & & (* __self_0_2)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_eth_min" , & & (* __self_0_3)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "to" , & & (* __self_0_4)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "deadline" , & & (* __self_0_5)) ; :: core :: fmt :: DebugStruct :: finish (debug_trait_builder) } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for RemoveLiquidityETHSupportingFeeOnTransferTokensCall { # [inline] fn default () -> RemoveLiquidityETHSupportingFeeOnTransferTokensCall { RemoveLiquidityETHSupportingFeeOnTransferTokensCall { token : :: core :: default :: Default :: default () , liquidity : :: core :: default :: Default :: default () , amount_token_min : :: core :: default :: Default :: default () , amount_eth_min : :: core :: default :: Default :: default () , to : :: core :: default :: Default :: default () , deadline : :: core :: default :: Default :: default () , } } } impl :: core :: marker :: StructuralEq for RemoveLiquidityETHSupportingFeeOnTransferTokensCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for RemoveLiquidityETHSupportingFeeOnTransferTokensCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; } } } impl :: core :: marker :: StructuralPartialEq for RemoveLiquidityETHSupportingFeeOnTransferTokensCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for RemoveLiquidityETHSupportingFeeOnTransferTokensCall { # [inline] fn eq (& self , other : & RemoveLiquidityETHSupportingFeeOnTransferTokensCall) -> bool { match * other { RemoveLiquidityETHSupportingFeeOnTransferTokensCall { token : ref __self_1_0 , liquidity : ref __self_1_1 , amount_token_min : ref __self_1_2 , amount_eth_min : ref __self_1_3 , to : ref __self_1_4 , deadline : ref __self_1_5 } => match * self { RemoveLiquidityETHSupportingFeeOnTransferTokensCall { token : ref __self_0_0 , liquidity : ref __self_0_1 , amount_token_min : ref __self_0_2 , amount_eth_min : ref __self_0_3 , to : ref __self_0_4 , deadline : ref __self_0_5 } => (* __self_0_0) == (* __self_1_0) && (* __self_0_1) == (* __self_1_1) && (* __self_0_2) == (* __self_1_2) && (* __self_0_3) == (* __self_1_3) && (* __self_0_4) == (* __self_1_4) && (* __self_0_5) == (* __self_1_5) , } , } } # [inline] fn ne (& self , other : & RemoveLiquidityETHSupportingFeeOnTransferTokensCall) -> bool { match * other { RemoveLiquidityETHSupportingFeeOnTransferTokensCall { token : ref __self_1_0 , liquidity : ref __self_1_1 , amount_token_min : ref __self_1_2 , amount_eth_min : ref __self_1_3 , to : ref __self_1_4 , deadline : ref __self_1_5 } => match * self { RemoveLiquidityETHSupportingFeeOnTransferTokensCall { token : ref __self_0_0 , liquidity : ref __self_0_1 , amount_token_min : ref __self_0_2 , amount_eth_min : ref __self_0_3 , to : ref __self_0_4 , deadline : ref __self_0_5 } => (* __self_0_0) != (* __self_1_0) || (* __self_0_1) != (* __self_1_1) || (* __self_0_2) != (* __self_1_2) || (* __self_0_3) != (* __self_1_3) || (* __self_0_4) != (* __self_1_4) || (* __self_0_5) != (* __self_1_5) , } , } } } impl ethers :: core :: abi :: AbiType for RemoveLiquidityETHSupportingFeeOnTransferTokensCall < > { fn param_type () -> ethers :: core :: abi :: ParamType { ethers :: core :: abi :: ParamType :: Tuple (< [_] > :: into_vec (box [< ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type ()])) } } impl ethers :: core :: abi :: AbiArrayType for RemoveLiquidityETHSupportingFeeOnTransferTokensCall < > { } impl ethers :: core :: abi :: Tokenizable for RemoveLiquidityETHSupportingFeeOnTransferTokensCall < > where ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if tokens . len () != 6usize { return Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected " , " tokens, got " , ": "] , & match (& 6usize , & tokens . len () , & tokens) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 2 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) ; } let mut iter = tokens . into_iter () ; Ok (Self { token : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , liquidity : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_token_min : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_eth_min : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , to : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , deadline : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , }) } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (< [_] > :: into_vec (box [self . token . into_token () , self . liquidity . into_token () , self . amount_token_min . into_token () , self . amount_eth_min . into_token () , self . to . into_token () , self . deadline . into_token ()])) } } impl ethers :: core :: abi :: TokenizableItem for RemoveLiquidityETHSupportingFeeOnTransferTokensCall < > where ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { } impl ethers :: contract :: EthCall for RemoveLiquidityETHSupportingFeeOnTransferTokensCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "removeLiquidityETHSupportingFeeOnTransferTokens" . into () } fn selector () -> ethers :: core :: types :: Selector { [175 , 41 , 121 , 235] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "removeLiquidityETHSupportingFeeOnTransferTokens(address,uint256,uint256,uint256,address,uint256)" . into () } } impl ethers :: core :: abi :: AbiDecode for RemoveLiquidityETHSupportingFeeOnTransferTokensCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize)] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for RemoveLiquidityETHSupportingFeeOnTransferTokensCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for RemoveLiquidityETHSupportingFeeOnTransferTokensCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . liquidity ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_token_min ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_eth_min ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . to ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . deadline ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; Ok (()) } } # [doc = "Container type for all input parameters for the `removeLiquidityETHWithPermit`function with signature `removeLiquidityETHWithPermit(address,uint256,uint256,uint256,address,uint256,bool,uint8,bytes32,bytes32)` and selector `[222, 217, 56, 42]`"] # [ethcall (name = "removeLiquidityETHWithPermit" , abi = "removeLiquidityETHWithPermit(address,uint256,uint256,uint256,address,uint256,bool,uint8,bytes32,bytes32)")] pub struct RemoveLiquidityETHWithPermitCall { pub token : ethers :: core :: types :: Address , pub liquidity : ethers :: core :: types :: U256 , pub amount_token_min : ethers :: core :: types :: U256 , pub amount_eth_min : ethers :: core :: types :: U256 , pub to : ethers :: core :: types :: Address , pub deadline : ethers :: core :: types :: U256 , pub approve_max : bool , pub v : u8 , pub r : [u8 ; 32] , pub s : [u8 ; 32] , } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for RemoveLiquidityETHWithPermitCall { # [inline] fn clone (& self) -> RemoveLiquidityETHWithPermitCall { match * self { RemoveLiquidityETHWithPermitCall { token : ref __self_0_0 , liquidity : ref __self_0_1 , amount_token_min : ref __self_0_2 , amount_eth_min : ref __self_0_3 , to : ref __self_0_4 , deadline : ref __self_0_5 , approve_max : ref __self_0_6 , v : ref __self_0_7 , r : ref __self_0_8 , s : ref __self_0_9 } => RemoveLiquidityETHWithPermitCall { token : :: core :: clone :: Clone :: clone (& (* __self_0_0)) , liquidity : :: core :: clone :: Clone :: clone (& (* __self_0_1)) , amount_token_min : :: core :: clone :: Clone :: clone (& (* __self_0_2)) , amount_eth_min : :: core :: clone :: Clone :: clone (& (* __self_0_3)) , to : :: core :: clone :: Clone :: clone (& (* __self_0_4)) , deadline : :: core :: clone :: Clone :: clone (& (* __self_0_5)) , approve_max : :: core :: clone :: Clone :: clone (& (* __self_0_6)) , v : :: core :: clone :: Clone :: clone (& (* __self_0_7)) , r : :: core :: clone :: Clone :: clone (& (* __self_0_8)) , s : :: core :: clone :: Clone :: clone (& (* __self_0_9)) , } , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for RemoveLiquidityETHWithPermitCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { RemoveLiquidityETHWithPermitCall { token : ref __self_0_0 , liquidity : ref __self_0_1 , amount_token_min : ref __self_0_2 , amount_eth_min : ref __self_0_3 , to : ref __self_0_4 , deadline : ref __self_0_5 , approve_max : ref __self_0_6 , v : ref __self_0_7 , r : ref __self_0_8 , s : ref __self_0_9 } => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_struct (f , "RemoveLiquidityETHWithPermitCall") ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "token" , & & (* __self_0_0)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "liquidity" , & & (* __self_0_1)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_token_min" , & & (* __self_0_2)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_eth_min" , & & (* __self_0_3)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "to" , & & (* __self_0_4)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "deadline" , & & (* __self_0_5)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "approve_max" , & & (* __self_0_6)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "v" , & & (* __self_0_7)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "r" , & & (* __self_0_8)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "s" , & & (* __self_0_9)) ; :: core :: fmt :: DebugStruct :: finish (debug_trait_builder) } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for RemoveLiquidityETHWithPermitCall { # [inline] fn default () -> RemoveLiquidityETHWithPermitCall { RemoveLiquidityETHWithPermitCall { token : :: core :: default :: Default :: default () , liquidity : :: core :: default :: Default :: default () , amount_token_min : :: core :: default :: Default :: default () , amount_eth_min : :: core :: default :: Default :: default () , to : :: core :: default :: Default :: default () , deadline : :: core :: default :: Default :: default () , approve_max : :: core :: default :: Default :: default () , v : :: core :: default :: Default :: default () , r : :: core :: default :: Default :: default () , s : :: core :: default :: Default :: default () , } } } impl :: core :: marker :: StructuralEq for RemoveLiquidityETHWithPermitCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for RemoveLiquidityETHWithPermitCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < bool > ; let _ : :: core :: cmp :: AssertParamIsEq < u8 > ; let _ : :: core :: cmp :: AssertParamIsEq < [u8 ; 32] > ; let _ : :: core :: cmp :: AssertParamIsEq < [u8 ; 32] > ; } } } impl :: core :: marker :: StructuralPartialEq for RemoveLiquidityETHWithPermitCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for RemoveLiquidityETHWithPermitCall { # [inline] fn eq (& self , other : & RemoveLiquidityETHWithPermitCall) -> bool { match * other { RemoveLiquidityETHWithPermitCall { token : ref __self_1_0 , liquidity : ref __self_1_1 , amount_token_min : ref __self_1_2 , amount_eth_min : ref __self_1_3 , to : ref __self_1_4 , deadline : ref __self_1_5 , approve_max : ref __self_1_6 , v : ref __self_1_7 , r : ref __self_1_8 , s : ref __self_1_9 } => match * self { RemoveLiquidityETHWithPermitCall { token : ref __self_0_0 , liquidity : ref __self_0_1 , amount_token_min : ref __self_0_2 , amount_eth_min : ref __self_0_3 , to : ref __self_0_4 , deadline : ref __self_0_5 , approve_max : ref __self_0_6 , v : ref __self_0_7 , r : ref __self_0_8 , s : ref __self_0_9 } => (* __self_0_0) == (* __self_1_0) && (* __self_0_1) == (* __self_1_1) && (* __self_0_2) == (* __self_1_2) && (* __self_0_3) == (* __self_1_3) && (* __self_0_4) == (* __self_1_4) && (* __self_0_5) == (* __self_1_5) && (* __self_0_6) == (* __self_1_6) && (* __self_0_7) == (* __self_1_7) && (* __self_0_8) == (* __self_1_8) && (* __self_0_9) == (* __self_1_9) , } , } } # [inline] fn ne (& self , other : & RemoveLiquidityETHWithPermitCall) -> bool { match * other { RemoveLiquidityETHWithPermitCall { token : ref __self_1_0 , liquidity : ref __self_1_1 , amount_token_min : ref __self_1_2 , amount_eth_min : ref __self_1_3 , to : ref __self_1_4 , deadline : ref __self_1_5 , approve_max : ref __self_1_6 , v : ref __self_1_7 , r : ref __self_1_8 , s : ref __self_1_9 } => match * self { RemoveLiquidityETHWithPermitCall { token : ref __self_0_0 , liquidity : ref __self_0_1 , amount_token_min : ref __self_0_2 , amount_eth_min : ref __self_0_3 , to : ref __self_0_4 , deadline : ref __self_0_5 , approve_max : ref __self_0_6 , v : ref __self_0_7 , r : ref __self_0_8 , s : ref __self_0_9 } => (* __self_0_0) != (* __self_1_0) || (* __self_0_1) != (* __self_1_1) || (* __self_0_2) != (* __self_1_2) || (* __self_0_3) != (* __self_1_3) || (* __self_0_4) != (* __self_1_4) || (* __self_0_5) != (* __self_1_5) || (* __self_0_6) != (* __self_1_6) || (* __self_0_7) != (* __self_1_7) || (* __self_0_8) != (* __self_1_8) || (* __self_0_9) != (* __self_1_9) , } , } } } impl ethers :: core :: abi :: AbiType for RemoveLiquidityETHWithPermitCall < > { fn param_type () -> ethers :: core :: abi :: ParamType { ethers :: core :: abi :: ParamType :: Tuple (< [_] > :: into_vec (box [< ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < bool as ethers :: core :: abi :: AbiType > :: param_type () , < u8 as ethers :: core :: abi :: AbiType > :: param_type () , < [u8 ; 32] as ethers :: core :: abi :: AbiType > :: param_type () , < [u8 ; 32] as ethers :: core :: abi :: AbiType > :: param_type ()])) } } impl ethers :: core :: abi :: AbiArrayType for RemoveLiquidityETHWithPermitCall < > { } impl ethers :: core :: abi :: Tokenizable for RemoveLiquidityETHWithPermitCall < > where ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , bool : ethers :: core :: abi :: Tokenize , u8 : ethers :: core :: abi :: Tokenize , [u8 ; 32] : ethers :: core :: abi :: Tokenize , [u8 ; 32] : ethers :: core :: abi :: Tokenize { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if tokens . len () != 10usize { return Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected " , " tokens, got " , ": "] , & match (& 10usize , & tokens . len () , & tokens) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 2 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) ; } let mut iter = tokens . into_iter () ; Ok (Self { token : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , liquidity : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_token_min : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_eth_min : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , to : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , deadline : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , approve_max : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , v : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , r : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , s : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , }) } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (< [_] > :: into_vec (box [self . token . into_token () , self . liquidity . into_token () , self . amount_token_min . into_token () , self . amount_eth_min . into_token () , self . to . into_token () , self . deadline . into_token () , self . approve_max . into_token () , self . v . into_token () , self . r . into_token () , self . s . into_token ()])) } } impl ethers :: core :: abi :: TokenizableItem for RemoveLiquidityETHWithPermitCall < > where ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , bool : ethers :: core :: abi :: Tokenize , u8 : ethers :: core :: abi :: Tokenize , [u8 ; 32] : ethers :: core :: abi :: Tokenize , [u8 ; 32] : ethers :: core :: abi :: Tokenize { } impl ethers :: contract :: EthCall for RemoveLiquidityETHWithPermitCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "removeLiquidityETHWithPermit" . into () } fn selector () -> ethers :: core :: types :: Selector { [222 , 217 , 56 , 42] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "removeLiquidityETHWithPermit(address,uint256,uint256,uint256,address,uint256,bool,uint8,bytes32,bytes32)" . into () } } impl ethers :: core :: abi :: AbiDecode for RemoveLiquidityETHWithPermitCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Bool , ethers :: core :: abi :: ParamType :: Uint (8usize) , ethers :: core :: abi :: ParamType :: FixedBytes (32usize) , ethers :: core :: abi :: ParamType :: FixedBytes (32usize)] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for RemoveLiquidityETHWithPermitCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for RemoveLiquidityETHWithPermitCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . liquidity ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_token_min ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_eth_min ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . to ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . deadline ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; self . approve_max . fmt (f) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& self . v ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& ["0x"] , & match (& ethers :: core :: utils :: hex :: encode (& self . r [..]) ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& ["0x"] , & match (& ethers :: core :: utils :: hex :: encode (& self . s [..]) ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt)] , })) ? ; Ok (()) } } # [doc = "Container type for all input parameters for the `removeLiquidityETHWithPermitSupportingFeeOnTransferTokens`function with signature `removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(address,uint256,uint256,uint256,address,uint256,bool,uint8,bytes32,bytes32)` and selector `[91, 13, 89, 132]`"] # [ethcall (name = "removeLiquidityETHWithPermitSupportingFeeOnTransferTokens" , abi = "removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(address,uint256,uint256,uint256,address,uint256,bool,uint8,bytes32,bytes32)")] pub struct RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall { pub token : ethers :: core :: types :: Address , pub liquidity : ethers :: core :: types :: U256 , pub amount_token_min : ethers :: core :: types :: U256 , pub amount_eth_min : ethers :: core :: types :: U256 , pub to : ethers :: core :: types :: Address , pub deadline : ethers :: core :: types :: U256 , pub approve_max : bool , pub v : u8 , pub r : [u8 ; 32] , pub s : [u8 ; 32] , } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall { # [inline] fn clone (& self) -> RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall { match * self { RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall { token : ref __self_0_0 , liquidity : ref __self_0_1 , amount_token_min : ref __self_0_2 , amount_eth_min : ref __self_0_3 , to : ref __self_0_4 , deadline : ref __self_0_5 , approve_max : ref __self_0_6 , v : ref __self_0_7 , r : ref __self_0_8 , s : ref __self_0_9 } => RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall { token : :: core :: clone :: Clone :: clone (& (* __self_0_0)) , liquidity : :: core :: clone :: Clone :: clone (& (* __self_0_1)) , amount_token_min : :: core :: clone :: Clone :: clone (& (* __self_0_2)) , amount_eth_min : :: core :: clone :: Clone :: clone (& (* __self_0_3)) , to : :: core :: clone :: Clone :: clone (& (* __self_0_4)) , deadline : :: core :: clone :: Clone :: clone (& (* __self_0_5)) , approve_max : :: core :: clone :: Clone :: clone (& (* __self_0_6)) , v : :: core :: clone :: Clone :: clone (& (* __self_0_7)) , r : :: core :: clone :: Clone :: clone (& (* __self_0_8)) , s : :: core :: clone :: Clone :: clone (& (* __self_0_9)) , } , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall { token : ref __self_0_0 , liquidity : ref __self_0_1 , amount_token_min : ref __self_0_2 , amount_eth_min : ref __self_0_3 , to : ref __self_0_4 , deadline : ref __self_0_5 , approve_max : ref __self_0_6 , v : ref __self_0_7 , r : ref __self_0_8 , s : ref __self_0_9 } => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_struct (f , "RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall") ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "token" , & & (* __self_0_0)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "liquidity" , & & (* __self_0_1)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_token_min" , & & (* __self_0_2)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_eth_min" , & & (* __self_0_3)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "to" , & & (* __self_0_4)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "deadline" , & & (* __self_0_5)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "approve_max" , & & (* __self_0_6)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "v" , & & (* __self_0_7)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "r" , & & (* __self_0_8)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "s" , & & (* __self_0_9)) ; :: core :: fmt :: DebugStruct :: finish (debug_trait_builder) } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall { # [inline] fn default () -> RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall { RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall { token : :: core :: default :: Default :: default () , liquidity : :: core :: default :: Default :: default () , amount_token_min : :: core :: default :: Default :: default () , amount_eth_min : :: core :: default :: Default :: default () , to : :: core :: default :: Default :: default () , deadline : :: core :: default :: Default :: default () , approve_max : :: core :: default :: Default :: default () , v : :: core :: default :: Default :: default () , r : :: core :: default :: Default :: default () , s : :: core :: default :: Default :: default () , } } } impl :: core :: marker :: StructuralEq for RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < bool > ; let _ : :: core :: cmp :: AssertParamIsEq < u8 > ; let _ : :: core :: cmp :: AssertParamIsEq < [u8 ; 32] > ; let _ : :: core :: cmp :: AssertParamIsEq < [u8 ; 32] > ; } } } impl :: core :: marker :: StructuralPartialEq for RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall { # [inline] fn eq (& self , other : & RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall) -> bool { match * other { RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall { token : ref __self_1_0 , liquidity : ref __self_1_1 , amount_token_min : ref __self_1_2 , amount_eth_min : ref __self_1_3 , to : ref __self_1_4 , deadline : ref __self_1_5 , approve_max : ref __self_1_6 , v : ref __self_1_7 , r : ref __self_1_8 , s : ref __self_1_9 } => match * self { RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall { token : ref __self_0_0 , liquidity : ref __self_0_1 , amount_token_min : ref __self_0_2 , amount_eth_min : ref __self_0_3 , to : ref __self_0_4 , deadline : ref __self_0_5 , approve_max : ref __self_0_6 , v : ref __self_0_7 , r : ref __self_0_8 , s : ref __self_0_9 } => (* __self_0_0) == (* __self_1_0) && (* __self_0_1) == (* __self_1_1) && (* __self_0_2) == (* __self_1_2) && (* __self_0_3) == (* __self_1_3) && (* __self_0_4) == (* __self_1_4) && (* __self_0_5) == (* __self_1_5) && (* __self_0_6) == (* __self_1_6) && (* __self_0_7) == (* __self_1_7) && (* __self_0_8) == (* __self_1_8) && (* __self_0_9) == (* __self_1_9) , } , } } # [inline] fn ne (& self , other : & RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall) -> bool { match * other { RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall { token : ref __self_1_0 , liquidity : ref __self_1_1 , amount_token_min : ref __self_1_2 , amount_eth_min : ref __self_1_3 , to : ref __self_1_4 , deadline : ref __self_1_5 , approve_max : ref __self_1_6 , v : ref __self_1_7 , r : ref __self_1_8 , s : ref __self_1_9 } => match * self { RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall { token : ref __self_0_0 , liquidity : ref __self_0_1 , amount_token_min : ref __self_0_2 , amount_eth_min : ref __self_0_3 , to : ref __self_0_4 , deadline : ref __self_0_5 , approve_max : ref __self_0_6 , v : ref __self_0_7 , r : ref __self_0_8 , s : ref __self_0_9 } => (* __self_0_0) != (* __self_1_0) || (* __self_0_1) != (* __self_1_1) || (* __self_0_2) != (* __self_1_2) || (* __self_0_3) != (* __self_1_3) || (* __self_0_4) != (* __self_1_4) || (* __self_0_5) != (* __self_1_5) || (* __self_0_6) != (* __self_1_6) || (* __self_0_7) != (* __self_1_7) || (* __self_0_8) != (* __self_1_8) || (* __self_0_9) != (* __self_1_9) , } , } } } impl ethers :: core :: abi :: AbiType for RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall < > { fn param_type () -> ethers :: core :: abi :: ParamType { ethers :: core :: abi :: ParamType :: Tuple (< [_] > :: into_vec (box [< ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < bool as ethers :: core :: abi :: AbiType > :: param_type () , < u8 as ethers :: core :: abi :: AbiType > :: param_type () , < [u8 ; 32] as ethers :: core :: abi :: AbiType > :: param_type () , < [u8 ; 32] as ethers :: core :: abi :: AbiType > :: param_type ()])) } } impl ethers :: core :: abi :: AbiArrayType for RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall < > { } impl ethers :: core :: abi :: Tokenizable for RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall < > where ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , bool : ethers :: core :: abi :: Tokenize , u8 : ethers :: core :: abi :: Tokenize , [u8 ; 32] : ethers :: core :: abi :: Tokenize , [u8 ; 32] : ethers :: core :: abi :: Tokenize { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if tokens . len () != 10usize { return Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected " , " tokens, got " , ": "] , & match (& 10usize , & tokens . len () , & tokens) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 2 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) ; } let mut iter = tokens . into_iter () ; Ok (Self { token : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , liquidity : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_token_min : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_eth_min : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , to : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , deadline : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , approve_max : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , v : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , r : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , s : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , }) } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (< [_] > :: into_vec (box [self . token . into_token () , self . liquidity . into_token () , self . amount_token_min . into_token () , self . amount_eth_min . into_token () , self . to . into_token () , self . deadline . into_token () , self . approve_max . into_token () , self . v . into_token () , self . r . into_token () , self . s . into_token ()])) } } impl ethers :: core :: abi :: TokenizableItem for RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall < > where ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , bool : ethers :: core :: abi :: Tokenize , u8 : ethers :: core :: abi :: Tokenize , [u8 ; 32] : ethers :: core :: abi :: Tokenize , [u8 ; 32] : ethers :: core :: abi :: Tokenize { } impl ethers :: contract :: EthCall for RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "removeLiquidityETHWithPermitSupportingFeeOnTransferTokens" . into () } fn selector () -> ethers :: core :: types :: Selector { [91 , 13 , 89 , 132] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(address,uint256,uint256,uint256,address,uint256,bool,uint8,bytes32,bytes32)" . into () } } impl ethers :: core :: abi :: AbiDecode for RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Bool , ethers :: core :: abi :: ParamType :: Uint (8usize) , ethers :: core :: abi :: ParamType :: FixedBytes (32usize) , ethers :: core :: abi :: ParamType :: FixedBytes (32usize)] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . liquidity ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_token_min ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_eth_min ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . to ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . deadline ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; self . approve_max . fmt (f) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& self . v ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& ["0x"] , & match (& ethers :: core :: utils :: hex :: encode (& self . r [..]) ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& ["0x"] , & match (& ethers :: core :: utils :: hex :: encode (& self . s [..]) ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt)] , })) ? ; Ok (()) } } # [doc = "Container type for all input parameters for the `removeLiquidityWithPermit`function with signature `removeLiquidityWithPermit(address,address,uint256,uint256,uint256,address,uint256,bool,uint8,bytes32,bytes32)` and selector `[33, 149, 153, 92]`"] # [ethcall (name = "removeLiquidityWithPermit" , abi = "removeLiquidityWithPermit(address,address,uint256,uint256,uint256,address,uint256,bool,uint8,bytes32,bytes32)")] pub struct RemoveLiquidityWithPermitCall { pub token_a : ethers :: core :: types :: Address , pub token_b : ethers :: core :: types :: Address , pub liquidity : ethers :: core :: types :: U256 , pub amount_a_min : ethers :: core :: types :: U256 , pub amount_b_min : ethers :: core :: types :: U256 , pub to : ethers :: core :: types :: Address , pub deadline : ethers :: core :: types :: U256 , pub approve_max : bool , pub v : u8 , pub r : [u8 ; 32] , pub s : [u8 ; 32] , } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for RemoveLiquidityWithPermitCall { # [inline] fn clone (& self) -> RemoveLiquidityWithPermitCall { match * self { RemoveLiquidityWithPermitCall { token_a : ref __self_0_0 , token_b : ref __self_0_1 , liquidity : ref __self_0_2 , amount_a_min : ref __self_0_3 , amount_b_min : ref __self_0_4 , to : ref __self_0_5 , deadline : ref __self_0_6 , approve_max : ref __self_0_7 , v : ref __self_0_8 , r : ref __self_0_9 , s : ref __self_0_10 } => RemoveLiquidityWithPermitCall { token_a : :: core :: clone :: Clone :: clone (& (* __self_0_0)) , token_b : :: core :: clone :: Clone :: clone (& (* __self_0_1)) , liquidity : :: core :: clone :: Clone :: clone (& (* __self_0_2)) , amount_a_min : :: core :: clone :: Clone :: clone (& (* __self_0_3)) , amount_b_min : :: core :: clone :: Clone :: clone (& (* __self_0_4)) , to : :: core :: clone :: Clone :: clone (& (* __self_0_5)) , deadline : :: core :: clone :: Clone :: clone (& (* __self_0_6)) , approve_max : :: core :: clone :: Clone :: clone (& (* __self_0_7)) , v : :: core :: clone :: Clone :: clone (& (* __self_0_8)) , r : :: core :: clone :: Clone :: clone (& (* __self_0_9)) , s : :: core :: clone :: Clone :: clone (& (* __self_0_10)) , } , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for RemoveLiquidityWithPermitCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { RemoveLiquidityWithPermitCall { token_a : ref __self_0_0 , token_b : ref __self_0_1 , liquidity : ref __self_0_2 , amount_a_min : ref __self_0_3 , amount_b_min : ref __self_0_4 , to : ref __self_0_5 , deadline : ref __self_0_6 , approve_max : ref __self_0_7 , v : ref __self_0_8 , r : ref __self_0_9 , s : ref __self_0_10 } => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_struct (f , "RemoveLiquidityWithPermitCall") ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "token_a" , & & (* __self_0_0)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "token_b" , & & (* __self_0_1)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "liquidity" , & & (* __self_0_2)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_a_min" , & & (* __self_0_3)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_b_min" , & & (* __self_0_4)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "to" , & & (* __self_0_5)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "deadline" , & & (* __self_0_6)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "approve_max" , & & (* __self_0_7)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "v" , & & (* __self_0_8)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "r" , & & (* __self_0_9)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "s" , & & (* __self_0_10)) ; :: core :: fmt :: DebugStruct :: finish (debug_trait_builder) } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for RemoveLiquidityWithPermitCall { # [inline] fn default () -> RemoveLiquidityWithPermitCall { RemoveLiquidityWithPermitCall { token_a : :: core :: default :: Default :: default () , token_b : :: core :: default :: Default :: default () , liquidity : :: core :: default :: Default :: default () , amount_a_min : :: core :: default :: Default :: default () , amount_b_min : :: core :: default :: Default :: default () , to : :: core :: default :: Default :: default () , deadline : :: core :: default :: Default :: default () , approve_max : :: core :: default :: Default :: default () , v : :: core :: default :: Default :: default () , r : :: core :: default :: Default :: default () , s : :: core :: default :: Default :: default () , } } } impl :: core :: marker :: StructuralEq for RemoveLiquidityWithPermitCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for RemoveLiquidityWithPermitCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < bool > ; let _ : :: core :: cmp :: AssertParamIsEq < u8 > ; let _ : :: core :: cmp :: AssertParamIsEq < [u8 ; 32] > ; let _ : :: core :: cmp :: AssertParamIsEq < [u8 ; 32] > ; } } } impl :: core :: marker :: StructuralPartialEq for RemoveLiquidityWithPermitCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for RemoveLiquidityWithPermitCall { # [inline] fn eq (& self , other : & RemoveLiquidityWithPermitCall) -> bool { match * other { RemoveLiquidityWithPermitCall { token_a : ref __self_1_0 , token_b : ref __self_1_1 , liquidity : ref __self_1_2 , amount_a_min : ref __self_1_3 , amount_b_min : ref __self_1_4 , to : ref __self_1_5 , deadline : ref __self_1_6 , approve_max : ref __self_1_7 , v : ref __self_1_8 , r : ref __self_1_9 , s : ref __self_1_10 } => match * self { RemoveLiquidityWithPermitCall { token_a : ref __self_0_0 , token_b : ref __self_0_1 , liquidity : ref __self_0_2 , amount_a_min : ref __self_0_3 , amount_b_min : ref __self_0_4 , to : ref __self_0_5 , deadline : ref __self_0_6 , approve_max : ref __self_0_7 , v : ref __self_0_8 , r : ref __self_0_9 , s : ref __self_0_10 } => (* __self_0_0) == (* __self_1_0) && (* __self_0_1) == (* __self_1_1) && (* __self_0_2) == (* __self_1_2) && (* __self_0_3) == (* __self_1_3) && (* __self_0_4) == (* __self_1_4) && (* __self_0_5) == (* __self_1_5) && (* __self_0_6) == (* __self_1_6) && (* __self_0_7) == (* __self_1_7) && (* __self_0_8) == (* __self_1_8) && (* __self_0_9) == (* __self_1_9) && (* __self_0_10) == (* __self_1_10) , } , } } # [inline] fn ne (& self , other : & RemoveLiquidityWithPermitCall) -> bool { match * other { RemoveLiquidityWithPermitCall { token_a : ref __self_1_0 , token_b : ref __self_1_1 , liquidity : ref __self_1_2 , amount_a_min : ref __self_1_3 , amount_b_min : ref __self_1_4 , to : ref __self_1_5 , deadline : ref __self_1_6 , approve_max : ref __self_1_7 , v : ref __self_1_8 , r : ref __self_1_9 , s : ref __self_1_10 } => match * self { RemoveLiquidityWithPermitCall { token_a : ref __self_0_0 , token_b : ref __self_0_1 , liquidity : ref __self_0_2 , amount_a_min : ref __self_0_3 , amount_b_min : ref __self_0_4 , to : ref __self_0_5 , deadline : ref __self_0_6 , approve_max : ref __self_0_7 , v : ref __self_0_8 , r : ref __self_0_9 , s : ref __self_0_10 } => (* __self_0_0) != (* __self_1_0) || (* __self_0_1) != (* __self_1_1) || (* __self_0_2) != (* __self_1_2) || (* __self_0_3) != (* __self_1_3) || (* __self_0_4) != (* __self_1_4) || (* __self_0_5) != (* __self_1_5) || (* __self_0_6) != (* __self_1_6) || (* __self_0_7) != (* __self_1_7) || (* __self_0_8) != (* __self_1_8) || (* __self_0_9) != (* __self_1_9) || (* __self_0_10) != (* __self_1_10) , } , } } } impl ethers :: core :: abi :: AbiType for RemoveLiquidityWithPermitCall < > { fn param_type () -> ethers :: core :: abi :: ParamType { ethers :: core :: abi :: ParamType :: Tuple (< [_] > :: into_vec (box [< ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < bool as ethers :: core :: abi :: AbiType > :: param_type () , < u8 as ethers :: core :: abi :: AbiType > :: param_type () , < [u8 ; 32] as ethers :: core :: abi :: AbiType > :: param_type () , < [u8 ; 32] as ethers :: core :: abi :: AbiType > :: param_type ()])) } } impl ethers :: core :: abi :: AbiArrayType for RemoveLiquidityWithPermitCall < > { } impl ethers :: core :: abi :: Tokenizable for RemoveLiquidityWithPermitCall < > where ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , bool : ethers :: core :: abi :: Tokenize , u8 : ethers :: core :: abi :: Tokenize , [u8 ; 32] : ethers :: core :: abi :: Tokenize , [u8 ; 32] : ethers :: core :: abi :: Tokenize { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if tokens . len () != 11usize { return Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected " , " tokens, got " , ": "] , & match (& 11usize , & tokens . len () , & tokens) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 2 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) ; } let mut iter = tokens . into_iter () ; Ok (Self { token_a : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , token_b : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , liquidity : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_a_min : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_b_min : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , to : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , deadline : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , approve_max : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , v : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , r : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , s : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , }) } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (< [_] > :: into_vec (box [self . token_a . into_token () , self . token_b . into_token () , self . liquidity . into_token () , self . amount_a_min . into_token () , self . amount_b_min . into_token () , self . to . into_token () , self . deadline . into_token () , self . approve_max . into_token () , self . v . into_token () , self . r . into_token () , self . s . into_token ()])) } } impl ethers :: core :: abi :: TokenizableItem for RemoveLiquidityWithPermitCall < > where ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , bool : ethers :: core :: abi :: Tokenize , u8 : ethers :: core :: abi :: Tokenize , [u8 ; 32] : ethers :: core :: abi :: Tokenize , [u8 ; 32] : ethers :: core :: abi :: Tokenize { } impl ethers :: contract :: EthCall for RemoveLiquidityWithPermitCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "removeLiquidityWithPermit" . into () } fn selector () -> ethers :: core :: types :: Selector { [33 , 149 , 153 , 92] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "removeLiquidityWithPermit(address,address,uint256,uint256,uint256,address,uint256,bool,uint8,bytes32,bytes32)" . into () } } impl ethers :: core :: abi :: AbiDecode for RemoveLiquidityWithPermitCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Bool , ethers :: core :: abi :: ParamType :: Uint (8usize) , ethers :: core :: abi :: ParamType :: FixedBytes (32usize) , ethers :: core :: abi :: ParamType :: FixedBytes (32usize)] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for RemoveLiquidityWithPermitCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for RemoveLiquidityWithPermitCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . token_a ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . token_b ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . liquidity ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_a_min ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_b_min ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . to ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . deadline ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; self . approve_max . fmt (f) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& self . v ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& ["0x"] , & match (& ethers :: core :: utils :: hex :: encode (& self . r [..]) ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& ["0x"] , & match (& ethers :: core :: utils :: hex :: encode (& self . s [..]) ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt)] , })) ? ; Ok (()) } } # [doc = "Container type for all input parameters for the `swapETHForExactTokens`function with signature `swapETHForExactTokens(uint256,address[],address,uint256)` and selector `[251, 59, 219, 65]`"] # [ethcall (name = "swapETHForExactTokens" , abi = "swapETHForExactTokens(uint256,address[],address,uint256)")] pub struct SwapETHForExactTokensCall { pub amount_out : ethers :: core :: types :: U256 , pub path : :: std :: vec :: Vec < ethers :: core :: types :: Address > , pub to : ethers :: core :: types :: Address , pub deadline : ethers :: core :: types :: U256 , } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for SwapETHForExactTokensCall { # [inline] fn clone (& self) -> SwapETHForExactTokensCall { match * self { SwapETHForExactTokensCall { amount_out : ref __self_0_0 , path : ref __self_0_1 , to : ref __self_0_2 , deadline : ref __self_0_3 } => SwapETHForExactTokensCall { amount_out : :: core :: clone :: Clone :: clone (& (* __self_0_0)) , path : :: core :: clone :: Clone :: clone (& (* __self_0_1)) , to : :: core :: clone :: Clone :: clone (& (* __self_0_2)) , deadline : :: core :: clone :: Clone :: clone (& (* __self_0_3)) , } , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for SwapETHForExactTokensCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { SwapETHForExactTokensCall { amount_out : ref __self_0_0 , path : ref __self_0_1 , to : ref __self_0_2 , deadline : ref __self_0_3 } => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_struct (f , "SwapETHForExactTokensCall") ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_out" , & & (* __self_0_0)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "path" , & & (* __self_0_1)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "to" , & & (* __self_0_2)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "deadline" , & & (* __self_0_3)) ; :: core :: fmt :: DebugStruct :: finish (debug_trait_builder) } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for SwapETHForExactTokensCall { # [inline] fn default () -> SwapETHForExactTokensCall { SwapETHForExactTokensCall { amount_out : :: core :: default :: Default :: default () , path : :: core :: default :: Default :: default () , to : :: core :: default :: Default :: default () , deadline : :: core :: default :: Default :: default () , } } } impl :: core :: marker :: StructuralEq for SwapETHForExactTokensCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for SwapETHForExactTokensCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < :: std :: vec :: Vec < ethers :: core :: types :: Address > > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; } } } impl :: core :: marker :: StructuralPartialEq for SwapETHForExactTokensCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for SwapETHForExactTokensCall { # [inline] fn eq (& self , other : & SwapETHForExactTokensCall) -> bool { match * other { SwapETHForExactTokensCall { amount_out : ref __self_1_0 , path : ref __self_1_1 , to : ref __self_1_2 , deadline : ref __self_1_3 } => match * self { SwapETHForExactTokensCall { amount_out : ref __self_0_0 , path : ref __self_0_1 , to : ref __self_0_2 , deadline : ref __self_0_3 } => (* __self_0_0) == (* __self_1_0) && (* __self_0_1) == (* __self_1_1) && (* __self_0_2) == (* __self_1_2) && (* __self_0_3) == (* __self_1_3) , } , } } # [inline] fn ne (& self , other : & SwapETHForExactTokensCall) -> bool { match * other { SwapETHForExactTokensCall { amount_out : ref __self_1_0 , path : ref __self_1_1 , to : ref __self_1_2 , deadline : ref __self_1_3 } => match * self { SwapETHForExactTokensCall { amount_out : ref __self_0_0 , path : ref __self_0_1 , to : ref __self_0_2 , deadline : ref __self_0_3 } => (* __self_0_0) != (* __self_1_0) || (* __self_0_1) != (* __self_1_1) || (* __self_0_2) != (* __self_1_2) || (* __self_0_3) != (* __self_1_3) , } , } } } impl ethers :: core :: abi :: AbiType for SwapETHForExactTokensCall < > { fn param_type () -> ethers :: core :: abi :: ParamType { ethers :: core :: abi :: ParamType :: Tuple (< [_] > :: into_vec (box [< ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < :: std :: vec :: Vec < ethers :: core :: types :: Address > as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type ()])) } } impl ethers :: core :: abi :: AbiArrayType for SwapETHForExactTokensCall < > { } impl ethers :: core :: abi :: Tokenizable for SwapETHForExactTokensCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , :: std :: vec :: Vec < ethers :: core :: types :: Address > : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if tokens . len () != 4usize { return Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected " , " tokens, got " , ": "] , & match (& 4usize , & tokens . len () , & tokens) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 2 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) ; } let mut iter = tokens . into_iter () ; Ok (Self { amount_out : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , path : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , to : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , deadline : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , }) } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (< [_] > :: into_vec (box [self . amount_out . into_token () , self . path . into_token () , self . to . into_token () , self . deadline . into_token ()])) } } impl ethers :: core :: abi :: TokenizableItem for SwapETHForExactTokensCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , :: std :: vec :: Vec < ethers :: core :: types :: Address > : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { } impl ethers :: contract :: EthCall for SwapETHForExactTokensCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "swapETHForExactTokens" . into () } fn selector () -> ethers :: core :: types :: Selector { [251 , 59 , 219 , 65] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "swapETHForExactTokens(uint256,address[],address,uint256)" . into () } } impl ethers :: core :: abi :: AbiDecode for SwapETHForExactTokensCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Array (Box :: new (ethers :: core :: abi :: ParamType :: Address)) , ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize)] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for SwapETHForExactTokensCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for SwapETHForExactTokensCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_out ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . path ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . to ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . deadline ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; Ok (()) } } # [doc = "Container type for all input parameters for the `swapExactETHForTokens`function with signature `swapExactETHForTokens(uint256,address[],address,uint256)` and selector `[127, 243, 106, 181]`"] # [ethcall (name = "swapExactETHForTokens" , abi = "swapExactETHForTokens(uint256,address[],address,uint256)")] pub struct SwapExactETHForTokensCall { pub amount_out_min : ethers :: core :: types :: U256 , pub path : :: std :: vec :: Vec < ethers :: core :: types :: Address > , pub to : ethers :: core :: types :: Address , pub deadline : ethers :: core :: types :: U256 , } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for SwapExactETHForTokensCall { # [inline] fn clone (& self) -> SwapExactETHForTokensCall { match * self { SwapExactETHForTokensCall { amount_out_min : ref __self_0_0 , path : ref __self_0_1 , to : ref __self_0_2 , deadline : ref __self_0_3 } => SwapExactETHForTokensCall { amount_out_min : :: core :: clone :: Clone :: clone (& (* __self_0_0)) , path : :: core :: clone :: Clone :: clone (& (* __self_0_1)) , to : :: core :: clone :: Clone :: clone (& (* __self_0_2)) , deadline : :: core :: clone :: Clone :: clone (& (* __self_0_3)) , } , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for SwapExactETHForTokensCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { SwapExactETHForTokensCall { amount_out_min : ref __self_0_0 , path : ref __self_0_1 , to : ref __self_0_2 , deadline : ref __self_0_3 } => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_struct (f , "SwapExactETHForTokensCall") ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_out_min" , & & (* __self_0_0)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "path" , & & (* __self_0_1)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "to" , & & (* __self_0_2)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "deadline" , & & (* __self_0_3)) ; :: core :: fmt :: DebugStruct :: finish (debug_trait_builder) } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for SwapExactETHForTokensCall { # [inline] fn default () -> SwapExactETHForTokensCall { SwapExactETHForTokensCall { amount_out_min : :: core :: default :: Default :: default () , path : :: core :: default :: Default :: default () , to : :: core :: default :: Default :: default () , deadline : :: core :: default :: Default :: default () , } } } impl :: core :: marker :: StructuralEq for SwapExactETHForTokensCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for SwapExactETHForTokensCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < :: std :: vec :: Vec < ethers :: core :: types :: Address > > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; } } } impl :: core :: marker :: StructuralPartialEq for SwapExactETHForTokensCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for SwapExactETHForTokensCall { # [inline] fn eq (& self , other : & SwapExactETHForTokensCall) -> bool { match * other { SwapExactETHForTokensCall { amount_out_min : ref __self_1_0 , path : ref __self_1_1 , to : ref __self_1_2 , deadline : ref __self_1_3 } => match * self { SwapExactETHForTokensCall { amount_out_min : ref __self_0_0 , path : ref __self_0_1 , to : ref __self_0_2 , deadline : ref __self_0_3 } => (* __self_0_0) == (* __self_1_0) && (* __self_0_1) == (* __self_1_1) && (* __self_0_2) == (* __self_1_2) && (* __self_0_3) == (* __self_1_3) , } , } } # [inline] fn ne (& self , other : & SwapExactETHForTokensCall) -> bool { match * other { SwapExactETHForTokensCall { amount_out_min : ref __self_1_0 , path : ref __self_1_1 , to : ref __self_1_2 , deadline : ref __self_1_3 } => match * self { SwapExactETHForTokensCall { amount_out_min : ref __self_0_0 , path : ref __self_0_1 , to : ref __self_0_2 , deadline : ref __self_0_3 } => (* __self_0_0) != (* __self_1_0) || (* __self_0_1) != (* __self_1_1) || (* __self_0_2) != (* __self_1_2) || (* __self_0_3) != (* __self_1_3) , } , } } } impl ethers :: core :: abi :: AbiType for SwapExactETHForTokensCall < > { fn param_type () -> ethers :: core :: abi :: ParamType { ethers :: core :: abi :: ParamType :: Tuple (< [_] > :: into_vec (box [< ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < :: std :: vec :: Vec < ethers :: core :: types :: Address > as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type ()])) } } impl ethers :: core :: abi :: AbiArrayType for SwapExactETHForTokensCall < > { } impl ethers :: core :: abi :: Tokenizable for SwapExactETHForTokensCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , :: std :: vec :: Vec < ethers :: core :: types :: Address > : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if tokens . len () != 4usize { return Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected " , " tokens, got " , ": "] , & match (& 4usize , & tokens . len () , & tokens) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 2 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) ; } let mut iter = tokens . into_iter () ; Ok (Self { amount_out_min : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , path : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , to : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , deadline : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , }) } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (< [_] > :: into_vec (box [self . amount_out_min . into_token () , self . path . into_token () , self . to . into_token () , self . deadline . into_token ()])) } } impl ethers :: core :: abi :: TokenizableItem for SwapExactETHForTokensCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , :: std :: vec :: Vec < ethers :: core :: types :: Address > : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { } impl ethers :: contract :: EthCall for SwapExactETHForTokensCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "swapExactETHForTokens" . into () } fn selector () -> ethers :: core :: types :: Selector { [127 , 243 , 106 , 181] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "swapExactETHForTokens(uint256,address[],address,uint256)" . into () } } impl ethers :: core :: abi :: AbiDecode for SwapExactETHForTokensCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Array (Box :: new (ethers :: core :: abi :: ParamType :: Address)) , ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize)] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for SwapExactETHForTokensCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for SwapExactETHForTokensCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_out_min ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . path ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . to ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . deadline ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; Ok (()) } } # [doc = "Container type for all input parameters for the `swapExactETHForTokensSupportingFeeOnTransferTokens`function with signature `swapExactETHForTokensSupportingFeeOnTransferTokens(uint256,address[],address,uint256)` and selector `[182, 249, 222, 149]`"] # [ethcall (name = "swapExactETHForTokensSupportingFeeOnTransferTokens" , abi = "swapExactETHForTokensSupportingFeeOnTransferTokens(uint256,address[],address,uint256)")] pub struct SwapExactETHForTokensSupportingFeeOnTransferTokensCall { pub amount_out_min : ethers :: core :: types :: U256 , pub path : :: std :: vec :: Vec < ethers :: core :: types :: Address > , pub to : ethers :: core :: types :: Address , pub deadline : ethers :: core :: types :: U256 , } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for SwapExactETHForTokensSupportingFeeOnTransferTokensCall { # [inline] fn clone (& self) -> SwapExactETHForTokensSupportingFeeOnTransferTokensCall { match * self { SwapExactETHForTokensSupportingFeeOnTransferTokensCall { amount_out_min : ref __self_0_0 , path : ref __self_0_1 , to : ref __self_0_2 , deadline : ref __self_0_3 } => SwapExactETHForTokensSupportingFeeOnTransferTokensCall { amount_out_min : :: core :: clone :: Clone :: clone (& (* __self_0_0)) , path : :: core :: clone :: Clone :: clone (& (* __self_0_1)) , to : :: core :: clone :: Clone :: clone (& (* __self_0_2)) , deadline : :: core :: clone :: Clone :: clone (& (* __self_0_3)) , } , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for SwapExactETHForTokensSupportingFeeOnTransferTokensCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { SwapExactETHForTokensSupportingFeeOnTransferTokensCall { amount_out_min : ref __self_0_0 , path : ref __self_0_1 , to : ref __self_0_2 , deadline : ref __self_0_3 } => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_struct (f , "SwapExactETHForTokensSupportingFeeOnTransferTokensCall") ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_out_min" , & & (* __self_0_0)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "path" , & & (* __self_0_1)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "to" , & & (* __self_0_2)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "deadline" , & & (* __self_0_3)) ; :: core :: fmt :: DebugStruct :: finish (debug_trait_builder) } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for SwapExactETHForTokensSupportingFeeOnTransferTokensCall { # [inline] fn default () -> SwapExactETHForTokensSupportingFeeOnTransferTokensCall { SwapExactETHForTokensSupportingFeeOnTransferTokensCall { amount_out_min : :: core :: default :: Default :: default () , path : :: core :: default :: Default :: default () , to : :: core :: default :: Default :: default () , deadline : :: core :: default :: Default :: default () , } } } impl :: core :: marker :: StructuralEq for SwapExactETHForTokensSupportingFeeOnTransferTokensCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for SwapExactETHForTokensSupportingFeeOnTransferTokensCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < :: std :: vec :: Vec < ethers :: core :: types :: Address > > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; } } } impl :: core :: marker :: StructuralPartialEq for SwapExactETHForTokensSupportingFeeOnTransferTokensCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for SwapExactETHForTokensSupportingFeeOnTransferTokensCall { # [inline] fn eq (& self , other : & SwapExactETHForTokensSupportingFeeOnTransferTokensCall) -> bool { match * other { SwapExactETHForTokensSupportingFeeOnTransferTokensCall { amount_out_min : ref __self_1_0 , path : ref __self_1_1 , to : ref __self_1_2 , deadline : ref __self_1_3 } => match * self { SwapExactETHForTokensSupportingFeeOnTransferTokensCall { amount_out_min : ref __self_0_0 , path : ref __self_0_1 , to : ref __self_0_2 , deadline : ref __self_0_3 } => (* __self_0_0) == (* __self_1_0) && (* __self_0_1) == (* __self_1_1) && (* __self_0_2) == (* __self_1_2) && (* __self_0_3) == (* __self_1_3) , } , } } # [inline] fn ne (& self , other : & SwapExactETHForTokensSupportingFeeOnTransferTokensCall) -> bool { match * other { SwapExactETHForTokensSupportingFeeOnTransferTokensCall { amount_out_min : ref __self_1_0 , path : ref __self_1_1 , to : ref __self_1_2 , deadline : ref __self_1_3 } => match * self { SwapExactETHForTokensSupportingFeeOnTransferTokensCall { amount_out_min : ref __self_0_0 , path : ref __self_0_1 , to : ref __self_0_2 , deadline : ref __self_0_3 } => (* __self_0_0) != (* __self_1_0) || (* __self_0_1) != (* __self_1_1) || (* __self_0_2) != (* __self_1_2) || (* __self_0_3) != (* __self_1_3) , } , } } } impl ethers :: core :: abi :: AbiType for SwapExactETHForTokensSupportingFeeOnTransferTokensCall < > { fn param_type () -> ethers :: core :: abi :: ParamType { ethers :: core :: abi :: ParamType :: Tuple (< [_] > :: into_vec (box [< ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < :: std :: vec :: Vec < ethers :: core :: types :: Address > as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type ()])) } } impl ethers :: core :: abi :: AbiArrayType for SwapExactETHForTokensSupportingFeeOnTransferTokensCall < > { } impl ethers :: core :: abi :: Tokenizable for SwapExactETHForTokensSupportingFeeOnTransferTokensCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , :: std :: vec :: Vec < ethers :: core :: types :: Address > : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if tokens . len () != 4usize { return Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected " , " tokens, got " , ": "] , & match (& 4usize , & tokens . len () , & tokens) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 2 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) ; } let mut iter = tokens . into_iter () ; Ok (Self { amount_out_min : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , path : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , to : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , deadline : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , }) } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (< [_] > :: into_vec (box [self . amount_out_min . into_token () , self . path . into_token () , self . to . into_token () , self . deadline . into_token ()])) } } impl ethers :: core :: abi :: TokenizableItem for SwapExactETHForTokensSupportingFeeOnTransferTokensCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , :: std :: vec :: Vec < ethers :: core :: types :: Address > : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { } impl ethers :: contract :: EthCall for SwapExactETHForTokensSupportingFeeOnTransferTokensCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "swapExactETHForTokensSupportingFeeOnTransferTokens" . into () } fn selector () -> ethers :: core :: types :: Selector { [182 , 249 , 222 , 149] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "swapExactETHForTokensSupportingFeeOnTransferTokens(uint256,address[],address,uint256)" . into () } } impl ethers :: core :: abi :: AbiDecode for SwapExactETHForTokensSupportingFeeOnTransferTokensCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Array (Box :: new (ethers :: core :: abi :: ParamType :: Address)) , ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize)] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for SwapExactETHForTokensSupportingFeeOnTransferTokensCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for SwapExactETHForTokensSupportingFeeOnTransferTokensCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_out_min ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . path ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . to ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . deadline ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; Ok (()) } } # [doc = "Container type for all input parameters for the `swapExactTokensForETH`function with signature `swapExactTokensForETH(uint256,uint256,address[],address,uint256)` and selector `[24, 203, 175, 229]`"] # [ethcall (name = "swapExactTokensForETH" , abi = "swapExactTokensForETH(uint256,uint256,address[],address,uint256)")] pub struct SwapExactTokensForETHCall { pub amount_in : ethers :: core :: types :: U256 , pub amount_out_min : ethers :: core :: types :: U256 , pub path : :: std :: vec :: Vec < ethers :: core :: types :: Address > , pub to : ethers :: core :: types :: Address , pub deadline : ethers :: core :: types :: U256 , } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for SwapExactTokensForETHCall { # [inline] fn clone (& self) -> SwapExactTokensForETHCall { match * self { SwapExactTokensForETHCall { amount_in : ref __self_0_0 , amount_out_min : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => SwapExactTokensForETHCall { amount_in : :: core :: clone :: Clone :: clone (& (* __self_0_0)) , amount_out_min : :: core :: clone :: Clone :: clone (& (* __self_0_1)) , path : :: core :: clone :: Clone :: clone (& (* __self_0_2)) , to : :: core :: clone :: Clone :: clone (& (* __self_0_3)) , deadline : :: core :: clone :: Clone :: clone (& (* __self_0_4)) , } , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for SwapExactTokensForETHCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { SwapExactTokensForETHCall { amount_in : ref __self_0_0 , amount_out_min : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_struct (f , "SwapExactTokensForETHCall") ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_in" , & & (* __self_0_0)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_out_min" , & & (* __self_0_1)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "path" , & & (* __self_0_2)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "to" , & & (* __self_0_3)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "deadline" , & & (* __self_0_4)) ; :: core :: fmt :: DebugStruct :: finish (debug_trait_builder) } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for SwapExactTokensForETHCall { # [inline] fn default () -> SwapExactTokensForETHCall { SwapExactTokensForETHCall { amount_in : :: core :: default :: Default :: default () , amount_out_min : :: core :: default :: Default :: default () , path : :: core :: default :: Default :: default () , to : :: core :: default :: Default :: default () , deadline : :: core :: default :: Default :: default () , } } } impl :: core :: marker :: StructuralEq for SwapExactTokensForETHCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for SwapExactTokensForETHCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < :: std :: vec :: Vec < ethers :: core :: types :: Address > > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; } } } impl :: core :: marker :: StructuralPartialEq for SwapExactTokensForETHCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for SwapExactTokensForETHCall { # [inline] fn eq (& self , other : & SwapExactTokensForETHCall) -> bool { match * other { SwapExactTokensForETHCall { amount_in : ref __self_1_0 , amount_out_min : ref __self_1_1 , path : ref __self_1_2 , to : ref __self_1_3 , deadline : ref __self_1_4 } => match * self { SwapExactTokensForETHCall { amount_in : ref __self_0_0 , amount_out_min : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => (* __self_0_0) == (* __self_1_0) && (* __self_0_1) == (* __self_1_1) && (* __self_0_2) == (* __self_1_2) && (* __self_0_3) == (* __self_1_3) && (* __self_0_4) == (* __self_1_4) , } , } } # [inline] fn ne (& self , other : & SwapExactTokensForETHCall) -> bool { match * other { SwapExactTokensForETHCall { amount_in : ref __self_1_0 , amount_out_min : ref __self_1_1 , path : ref __self_1_2 , to : ref __self_1_3 , deadline : ref __self_1_4 } => match * self { SwapExactTokensForETHCall { amount_in : ref __self_0_0 , amount_out_min : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => (* __self_0_0) != (* __self_1_0) || (* __self_0_1) != (* __self_1_1) || (* __self_0_2) != (* __self_1_2) || (* __self_0_3) != (* __self_1_3) || (* __self_0_4) != (* __self_1_4) , } , } } } impl ethers :: core :: abi :: AbiType for SwapExactTokensForETHCall < > { fn param_type () -> ethers :: core :: abi :: ParamType { ethers :: core :: abi :: ParamType :: Tuple (< [_] > :: into_vec (box [< ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < :: std :: vec :: Vec < ethers :: core :: types :: Address > as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type ()])) } } impl ethers :: core :: abi :: AbiArrayType for SwapExactTokensForETHCall < > { } impl ethers :: core :: abi :: Tokenizable for SwapExactTokensForETHCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , :: std :: vec :: Vec < ethers :: core :: types :: Address > : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if tokens . len () != 5usize { return Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected " , " tokens, got " , ": "] , & match (& 5usize , & tokens . len () , & tokens) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 2 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) ; } let mut iter = tokens . into_iter () ; Ok (Self { amount_in : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_out_min : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , path : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , to : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , deadline : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , }) } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (< [_] > :: into_vec (box [self . amount_in . into_token () , self . amount_out_min . into_token () , self . path . into_token () , self . to . into_token () , self . deadline . into_token ()])) } } impl ethers :: core :: abi :: TokenizableItem for SwapExactTokensForETHCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , :: std :: vec :: Vec < ethers :: core :: types :: Address > : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { } impl ethers :: contract :: EthCall for SwapExactTokensForETHCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "swapExactTokensForETH" . into () } fn selector () -> ethers :: core :: types :: Selector { [24 , 203 , 175 , 229] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "swapExactTokensForETH(uint256,uint256,address[],address,uint256)" . into () } } impl ethers :: core :: abi :: AbiDecode for SwapExactTokensForETHCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Array (Box :: new (ethers :: core :: abi :: ParamType :: Address)) , ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize)] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for SwapExactTokensForETHCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for SwapExactTokensForETHCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_in ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_out_min ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . path ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . to ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . deadline ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; Ok (()) } } # [doc = "Container type for all input parameters for the `swapExactTokensForETHSupportingFeeOnTransferTokens`function with signature `swapExactTokensForETHSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)` and selector `[121, 26, 201, 71]`"] # [ethcall (name = "swapExactTokensForETHSupportingFeeOnTransferTokens" , abi = "swapExactTokensForETHSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)")] pub struct SwapExactTokensForETHSupportingFeeOnTransferTokensCall { pub amount_in : ethers :: core :: types :: U256 , pub amount_out_min : ethers :: core :: types :: U256 , pub path : :: std :: vec :: Vec < ethers :: core :: types :: Address > , pub to : ethers :: core :: types :: Address , pub deadline : ethers :: core :: types :: U256 , } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for SwapExactTokensForETHSupportingFeeOnTransferTokensCall { # [inline] fn clone (& self) -> SwapExactTokensForETHSupportingFeeOnTransferTokensCall { match * self { SwapExactTokensForETHSupportingFeeOnTransferTokensCall { amount_in : ref __self_0_0 , amount_out_min : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => SwapExactTokensForETHSupportingFeeOnTransferTokensCall { amount_in : :: core :: clone :: Clone :: clone (& (* __self_0_0)) , amount_out_min : :: core :: clone :: Clone :: clone (& (* __self_0_1)) , path : :: core :: clone :: Clone :: clone (& (* __self_0_2)) , to : :: core :: clone :: Clone :: clone (& (* __self_0_3)) , deadline : :: core :: clone :: Clone :: clone (& (* __self_0_4)) , } , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for SwapExactTokensForETHSupportingFeeOnTransferTokensCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { SwapExactTokensForETHSupportingFeeOnTransferTokensCall { amount_in : ref __self_0_0 , amount_out_min : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_struct (f , "SwapExactTokensForETHSupportingFeeOnTransferTokensCall") ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_in" , & & (* __self_0_0)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_out_min" , & & (* __self_0_1)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "path" , & & (* __self_0_2)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "to" , & & (* __self_0_3)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "deadline" , & & (* __self_0_4)) ; :: core :: fmt :: DebugStruct :: finish (debug_trait_builder) } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for SwapExactTokensForETHSupportingFeeOnTransferTokensCall { # [inline] fn default () -> SwapExactTokensForETHSupportingFeeOnTransferTokensCall { SwapExactTokensForETHSupportingFeeOnTransferTokensCall { amount_in : :: core :: default :: Default :: default () , amount_out_min : :: core :: default :: Default :: default () , path : :: core :: default :: Default :: default () , to : :: core :: default :: Default :: default () , deadline : :: core :: default :: Default :: default () , } } } impl :: core :: marker :: StructuralEq for SwapExactTokensForETHSupportingFeeOnTransferTokensCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for SwapExactTokensForETHSupportingFeeOnTransferTokensCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < :: std :: vec :: Vec < ethers :: core :: types :: Address > > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; } } } impl :: core :: marker :: StructuralPartialEq for SwapExactTokensForETHSupportingFeeOnTransferTokensCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for SwapExactTokensForETHSupportingFeeOnTransferTokensCall { # [inline] fn eq (& self , other : & SwapExactTokensForETHSupportingFeeOnTransferTokensCall) -> bool { match * other { SwapExactTokensForETHSupportingFeeOnTransferTokensCall { amount_in : ref __self_1_0 , amount_out_min : ref __self_1_1 , path : ref __self_1_2 , to : ref __self_1_3 , deadline : ref __self_1_4 } => match * self { SwapExactTokensForETHSupportingFeeOnTransferTokensCall { amount_in : ref __self_0_0 , amount_out_min : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => (* __self_0_0) == (* __self_1_0) && (* __self_0_1) == (* __self_1_1) && (* __self_0_2) == (* __self_1_2) && (* __self_0_3) == (* __self_1_3) && (* __self_0_4) == (* __self_1_4) , } , } } # [inline] fn ne (& self , other : & SwapExactTokensForETHSupportingFeeOnTransferTokensCall) -> bool { match * other { SwapExactTokensForETHSupportingFeeOnTransferTokensCall { amount_in : ref __self_1_0 , amount_out_min : ref __self_1_1 , path : ref __self_1_2 , to : ref __self_1_3 , deadline : ref __self_1_4 } => match * self { SwapExactTokensForETHSupportingFeeOnTransferTokensCall { amount_in : ref __self_0_0 , amount_out_min : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => (* __self_0_0) != (* __self_1_0) || (* __self_0_1) != (* __self_1_1) || (* __self_0_2) != (* __self_1_2) || (* __self_0_3) != (* __self_1_3) || (* __self_0_4) != (* __self_1_4) , } , } } } impl ethers :: core :: abi :: AbiType for SwapExactTokensForETHSupportingFeeOnTransferTokensCall < > { fn param_type () -> ethers :: core :: abi :: ParamType { ethers :: core :: abi :: ParamType :: Tuple (< [_] > :: into_vec (box [< ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < :: std :: vec :: Vec < ethers :: core :: types :: Address > as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type ()])) } } impl ethers :: core :: abi :: AbiArrayType for SwapExactTokensForETHSupportingFeeOnTransferTokensCall < > { } impl ethers :: core :: abi :: Tokenizable for SwapExactTokensForETHSupportingFeeOnTransferTokensCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , :: std :: vec :: Vec < ethers :: core :: types :: Address > : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if tokens . len () != 5usize { return Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected " , " tokens, got " , ": "] , & match (& 5usize , & tokens . len () , & tokens) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 2 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) ; } let mut iter = tokens . into_iter () ; Ok (Self { amount_in : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_out_min : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , path : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , to : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , deadline : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , }) } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (< [_] > :: into_vec (box [self . amount_in . into_token () , self . amount_out_min . into_token () , self . path . into_token () , self . to . into_token () , self . deadline . into_token ()])) } } impl ethers :: core :: abi :: TokenizableItem for SwapExactTokensForETHSupportingFeeOnTransferTokensCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , :: std :: vec :: Vec < ethers :: core :: types :: Address > : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { } impl ethers :: contract :: EthCall for SwapExactTokensForETHSupportingFeeOnTransferTokensCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "swapExactTokensForETHSupportingFeeOnTransferTokens" . into () } fn selector () -> ethers :: core :: types :: Selector { [121 , 26 , 201 , 71] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "swapExactTokensForETHSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)" . into () } } impl ethers :: core :: abi :: AbiDecode for SwapExactTokensForETHSupportingFeeOnTransferTokensCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Array (Box :: new (ethers :: core :: abi :: ParamType :: Address)) , ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize)] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for SwapExactTokensForETHSupportingFeeOnTransferTokensCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for SwapExactTokensForETHSupportingFeeOnTransferTokensCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_in ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_out_min ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . path ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . to ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . deadline ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; Ok (()) } } # [doc = "Container type for all input parameters for the `swapExactTokensForTokens`function with signature `swapExactTokensForTokens(uint256,uint256,address[],address,uint256)` and selector `[56, 237, 23, 57]`"] # [ethcall (name = "swapExactTokensForTokens" , abi = "swapExactTokensForTokens(uint256,uint256,address[],address,uint256)")] pub struct SwapExactTokensForTokensCall { pub amount_in : ethers :: core :: types :: U256 , pub amount_out_min : ethers :: core :: types :: U256 , pub path : :: std :: vec :: Vec < ethers :: core :: types :: Address > , pub to : ethers :: core :: types :: Address , pub deadline : ethers :: core :: types :: U256 , } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for SwapExactTokensForTokensCall { # [inline] fn clone (& self) -> SwapExactTokensForTokensCall { match * self { SwapExactTokensForTokensCall { amount_in : ref __self_0_0 , amount_out_min : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => SwapExactTokensForTokensCall { amount_in : :: core :: clone :: Clone :: clone (& (* __self_0_0)) , amount_out_min : :: core :: clone :: Clone :: clone (& (* __self_0_1)) , path : :: core :: clone :: Clone :: clone (& (* __self_0_2)) , to : :: core :: clone :: Clone :: clone (& (* __self_0_3)) , deadline : :: core :: clone :: Clone :: clone (& (* __self_0_4)) , } , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for SwapExactTokensForTokensCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { SwapExactTokensForTokensCall { amount_in : ref __self_0_0 , amount_out_min : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_struct (f , "SwapExactTokensForTokensCall") ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_in" , & & (* __self_0_0)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_out_min" , & & (* __self_0_1)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "path" , & & (* __self_0_2)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "to" , & & (* __self_0_3)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "deadline" , & & (* __self_0_4)) ; :: core :: fmt :: DebugStruct :: finish (debug_trait_builder) } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for SwapExactTokensForTokensCall { # [inline] fn default () -> SwapExactTokensForTokensCall { SwapExactTokensForTokensCall { amount_in : :: core :: default :: Default :: default () , amount_out_min : :: core :: default :: Default :: default () , path : :: core :: default :: Default :: default () , to : :: core :: default :: Default :: default () , deadline : :: core :: default :: Default :: default () , } } } impl :: core :: marker :: StructuralEq for SwapExactTokensForTokensCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for SwapExactTokensForTokensCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < :: std :: vec :: Vec < ethers :: core :: types :: Address > > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; } } } impl :: core :: marker :: StructuralPartialEq for SwapExactTokensForTokensCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for SwapExactTokensForTokensCall { # [inline] fn eq (& self , other : & SwapExactTokensForTokensCall) -> bool { match * other { SwapExactTokensForTokensCall { amount_in : ref __self_1_0 , amount_out_min : ref __self_1_1 , path : ref __self_1_2 , to : ref __self_1_3 , deadline : ref __self_1_4 } => match * self { SwapExactTokensForTokensCall { amount_in : ref __self_0_0 , amount_out_min : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => (* __self_0_0) == (* __self_1_0) && (* __self_0_1) == (* __self_1_1) && (* __self_0_2) == (* __self_1_2) && (* __self_0_3) == (* __self_1_3) && (* __self_0_4) == (* __self_1_4) , } , } } # [inline] fn ne (& self , other : & SwapExactTokensForTokensCall) -> bool { match * other { SwapExactTokensForTokensCall { amount_in : ref __self_1_0 , amount_out_min : ref __self_1_1 , path : ref __self_1_2 , to : ref __self_1_3 , deadline : ref __self_1_4 } => match * self { SwapExactTokensForTokensCall { amount_in : ref __self_0_0 , amount_out_min : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => (* __self_0_0) != (* __self_1_0) || (* __self_0_1) != (* __self_1_1) || (* __self_0_2) != (* __self_1_2) || (* __self_0_3) != (* __self_1_3) || (* __self_0_4) != (* __self_1_4) , } , } } } impl ethers :: core :: abi :: AbiType for SwapExactTokensForTokensCall < > { fn param_type () -> ethers :: core :: abi :: ParamType { ethers :: core :: abi :: ParamType :: Tuple (< [_] > :: into_vec (box [< ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < :: std :: vec :: Vec < ethers :: core :: types :: Address > as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type ()])) } } impl ethers :: core :: abi :: AbiArrayType for SwapExactTokensForTokensCall < > { } impl ethers :: core :: abi :: Tokenizable for SwapExactTokensForTokensCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , :: std :: vec :: Vec < ethers :: core :: types :: Address > : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if tokens . len () != 5usize { return Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected " , " tokens, got " , ": "] , & match (& 5usize , & tokens . len () , & tokens) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 2 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) ; } let mut iter = tokens . into_iter () ; Ok (Self { amount_in : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_out_min : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , path : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , to : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , deadline : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , }) } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (< [_] > :: into_vec (box [self . amount_in . into_token () , self . amount_out_min . into_token () , self . path . into_token () , self . to . into_token () , self . deadline . into_token ()])) } } impl ethers :: core :: abi :: TokenizableItem for SwapExactTokensForTokensCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , :: std :: vec :: Vec < ethers :: core :: types :: Address > : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { } impl ethers :: contract :: EthCall for SwapExactTokensForTokensCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "swapExactTokensForTokens" . into () } fn selector () -> ethers :: core :: types :: Selector { [56 , 237 , 23 , 57] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "swapExactTokensForTokens(uint256,uint256,address[],address,uint256)" . into () } } impl ethers :: core :: abi :: AbiDecode for SwapExactTokensForTokensCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Array (Box :: new (ethers :: core :: abi :: ParamType :: Address)) , ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize)] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for SwapExactTokensForTokensCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for SwapExactTokensForTokensCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_in ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_out_min ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . path ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . to ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . deadline ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; Ok (()) } } # [doc = "Container type for all input parameters for the `swapExactTokensForTokensSupportingFeeOnTransferTokens`function with signature `swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)` and selector `[92, 17, 215, 149]`"] # [ethcall (name = "swapExactTokensForTokensSupportingFeeOnTransferTokens" , abi = "swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)")] pub struct SwapExactTokensForTokensSupportingFeeOnTransferTokensCall { pub amount_in : ethers :: core :: types :: U256 , pub amount_out_min : ethers :: core :: types :: U256 , pub path : :: std :: vec :: Vec < ethers :: core :: types :: Address > , pub to : ethers :: core :: types :: Address , pub deadline : ethers :: core :: types :: U256 , } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for SwapExactTokensForTokensSupportingFeeOnTransferTokensCall { # [inline] fn clone (& self) -> SwapExactTokensForTokensSupportingFeeOnTransferTokensCall { match * self { SwapExactTokensForTokensSupportingFeeOnTransferTokensCall { amount_in : ref __self_0_0 , amount_out_min : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => SwapExactTokensForTokensSupportingFeeOnTransferTokensCall { amount_in : :: core :: clone :: Clone :: clone (& (* __self_0_0)) , amount_out_min : :: core :: clone :: Clone :: clone (& (* __self_0_1)) , path : :: core :: clone :: Clone :: clone (& (* __self_0_2)) , to : :: core :: clone :: Clone :: clone (& (* __self_0_3)) , deadline : :: core :: clone :: Clone :: clone (& (* __self_0_4)) , } , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for SwapExactTokensForTokensSupportingFeeOnTransferTokensCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { SwapExactTokensForTokensSupportingFeeOnTransferTokensCall { amount_in : ref __self_0_0 , amount_out_min : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_struct (f , "SwapExactTokensForTokensSupportingFeeOnTransferTokensCall") ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_in" , & & (* __self_0_0)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_out_min" , & & (* __self_0_1)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "path" , & & (* __self_0_2)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "to" , & & (* __self_0_3)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "deadline" , & & (* __self_0_4)) ; :: core :: fmt :: DebugStruct :: finish (debug_trait_builder) } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for SwapExactTokensForTokensSupportingFeeOnTransferTokensCall { # [inline] fn default () -> SwapExactTokensForTokensSupportingFeeOnTransferTokensCall { SwapExactTokensForTokensSupportingFeeOnTransferTokensCall { amount_in : :: core :: default :: Default :: default () , amount_out_min : :: core :: default :: Default :: default () , path : :: core :: default :: Default :: default () , to : :: core :: default :: Default :: default () , deadline : :: core :: default :: Default :: default () , } } } impl :: core :: marker :: StructuralEq for SwapExactTokensForTokensSupportingFeeOnTransferTokensCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for SwapExactTokensForTokensSupportingFeeOnTransferTokensCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < :: std :: vec :: Vec < ethers :: core :: types :: Address > > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; } } } impl :: core :: marker :: StructuralPartialEq for SwapExactTokensForTokensSupportingFeeOnTransferTokensCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for SwapExactTokensForTokensSupportingFeeOnTransferTokensCall { # [inline] fn eq (& self , other : & SwapExactTokensForTokensSupportingFeeOnTransferTokensCall) -> bool { match * other { SwapExactTokensForTokensSupportingFeeOnTransferTokensCall { amount_in : ref __self_1_0 , amount_out_min : ref __self_1_1 , path : ref __self_1_2 , to : ref __self_1_3 , deadline : ref __self_1_4 } => match * self { SwapExactTokensForTokensSupportingFeeOnTransferTokensCall { amount_in : ref __self_0_0 , amount_out_min : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => (* __self_0_0) == (* __self_1_0) && (* __self_0_1) == (* __self_1_1) && (* __self_0_2) == (* __self_1_2) && (* __self_0_3) == (* __self_1_3) && (* __self_0_4) == (* __self_1_4) , } , } } # [inline] fn ne (& self , other : & SwapExactTokensForTokensSupportingFeeOnTransferTokensCall) -> bool { match * other { SwapExactTokensForTokensSupportingFeeOnTransferTokensCall { amount_in : ref __self_1_0 , amount_out_min : ref __self_1_1 , path : ref __self_1_2 , to : ref __self_1_3 , deadline : ref __self_1_4 } => match * self { SwapExactTokensForTokensSupportingFeeOnTransferTokensCall { amount_in : ref __self_0_0 , amount_out_min : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => (* __self_0_0) != (* __self_1_0) || (* __self_0_1) != (* __self_1_1) || (* __self_0_2) != (* __self_1_2) || (* __self_0_3) != (* __self_1_3) || (* __self_0_4) != (* __self_1_4) , } , } } } impl ethers :: core :: abi :: AbiType for SwapExactTokensForTokensSupportingFeeOnTransferTokensCall < > { fn param_type () -> ethers :: core :: abi :: ParamType { ethers :: core :: abi :: ParamType :: Tuple (< [_] > :: into_vec (box [< ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < :: std :: vec :: Vec < ethers :: core :: types :: Address > as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type ()])) } } impl ethers :: core :: abi :: AbiArrayType for SwapExactTokensForTokensSupportingFeeOnTransferTokensCall < > { } impl ethers :: core :: abi :: Tokenizable for SwapExactTokensForTokensSupportingFeeOnTransferTokensCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , :: std :: vec :: Vec < ethers :: core :: types :: Address > : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if tokens . len () != 5usize { return Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected " , " tokens, got " , ": "] , & match (& 5usize , & tokens . len () , & tokens) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 2 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) ; } let mut iter = tokens . into_iter () ; Ok (Self { amount_in : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_out_min : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , path : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , to : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , deadline : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , }) } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (< [_] > :: into_vec (box [self . amount_in . into_token () , self . amount_out_min . into_token () , self . path . into_token () , self . to . into_token () , self . deadline . into_token ()])) } } impl ethers :: core :: abi :: TokenizableItem for SwapExactTokensForTokensSupportingFeeOnTransferTokensCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , :: std :: vec :: Vec < ethers :: core :: types :: Address > : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { } impl ethers :: contract :: EthCall for SwapExactTokensForTokensSupportingFeeOnTransferTokensCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "swapExactTokensForTokensSupportingFeeOnTransferTokens" . into () } fn selector () -> ethers :: core :: types :: Selector { [92 , 17 , 215 , 149] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)" . into () } } impl ethers :: core :: abi :: AbiDecode for SwapExactTokensForTokensSupportingFeeOnTransferTokensCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Array (Box :: new (ethers :: core :: abi :: ParamType :: Address)) , ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize)] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for SwapExactTokensForTokensSupportingFeeOnTransferTokensCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for SwapExactTokensForTokensSupportingFeeOnTransferTokensCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_in ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_out_min ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . path ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . to ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . deadline ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; Ok (()) } } # [doc = "Container type for all input parameters for the `swapTokensForExactETH`function with signature `swapTokensForExactETH(uint256,uint256,address[],address,uint256)` and selector `[74, 37, 217, 74]`"] # [ethcall (name = "swapTokensForExactETH" , abi = "swapTokensForExactETH(uint256,uint256,address[],address,uint256)")] pub struct SwapTokensForExactETHCall { pub amount_out : ethers :: core :: types :: U256 , pub amount_in_max : ethers :: core :: types :: U256 , pub path : :: std :: vec :: Vec < ethers :: core :: types :: Address > , pub to : ethers :: core :: types :: Address , pub deadline : ethers :: core :: types :: U256 , } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for SwapTokensForExactETHCall { # [inline] fn clone (& self) -> SwapTokensForExactETHCall { match * self { SwapTokensForExactETHCall { amount_out : ref __self_0_0 , amount_in_max : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => SwapTokensForExactETHCall { amount_out : :: core :: clone :: Clone :: clone (& (* __self_0_0)) , amount_in_max : :: core :: clone :: Clone :: clone (& (* __self_0_1)) , path : :: core :: clone :: Clone :: clone (& (* __self_0_2)) , to : :: core :: clone :: Clone :: clone (& (* __self_0_3)) , deadline : :: core :: clone :: Clone :: clone (& (* __self_0_4)) , } , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for SwapTokensForExactETHCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { SwapTokensForExactETHCall { amount_out : ref __self_0_0 , amount_in_max : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_struct (f , "SwapTokensForExactETHCall") ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_out" , & & (* __self_0_0)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_in_max" , & & (* __self_0_1)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "path" , & & (* __self_0_2)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "to" , & & (* __self_0_3)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "deadline" , & & (* __self_0_4)) ; :: core :: fmt :: DebugStruct :: finish (debug_trait_builder) } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for SwapTokensForExactETHCall { # [inline] fn default () -> SwapTokensForExactETHCall { SwapTokensForExactETHCall { amount_out : :: core :: default :: Default :: default () , amount_in_max : :: core :: default :: Default :: default () , path : :: core :: default :: Default :: default () , to : :: core :: default :: Default :: default () , deadline : :: core :: default :: Default :: default () , } } } impl :: core :: marker :: StructuralEq for SwapTokensForExactETHCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for SwapTokensForExactETHCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < :: std :: vec :: Vec < ethers :: core :: types :: Address > > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; } } } impl :: core :: marker :: StructuralPartialEq for SwapTokensForExactETHCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for SwapTokensForExactETHCall { # [inline] fn eq (& self , other : & SwapTokensForExactETHCall) -> bool { match * other { SwapTokensForExactETHCall { amount_out : ref __self_1_0 , amount_in_max : ref __self_1_1 , path : ref __self_1_2 , to : ref __self_1_3 , deadline : ref __self_1_4 } => match * self { SwapTokensForExactETHCall { amount_out : ref __self_0_0 , amount_in_max : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => (* __self_0_0) == (* __self_1_0) && (* __self_0_1) == (* __self_1_1) && (* __self_0_2) == (* __self_1_2) && (* __self_0_3) == (* __self_1_3) && (* __self_0_4) == (* __self_1_4) , } , } } # [inline] fn ne (& self , other : & SwapTokensForExactETHCall) -> bool { match * other { SwapTokensForExactETHCall { amount_out : ref __self_1_0 , amount_in_max : ref __self_1_1 , path : ref __self_1_2 , to : ref __self_1_3 , deadline : ref __self_1_4 } => match * self { SwapTokensForExactETHCall { amount_out : ref __self_0_0 , amount_in_max : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => (* __self_0_0) != (* __self_1_0) || (* __self_0_1) != (* __self_1_1) || (* __self_0_2) != (* __self_1_2) || (* __self_0_3) != (* __self_1_3) || (* __self_0_4) != (* __self_1_4) , } , } } } impl ethers :: core :: abi :: AbiType for SwapTokensForExactETHCall < > { fn param_type () -> ethers :: core :: abi :: ParamType { ethers :: core :: abi :: ParamType :: Tuple (< [_] > :: into_vec (box [< ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < :: std :: vec :: Vec < ethers :: core :: types :: Address > as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type ()])) } } impl ethers :: core :: abi :: AbiArrayType for SwapTokensForExactETHCall < > { } impl ethers :: core :: abi :: Tokenizable for SwapTokensForExactETHCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , :: std :: vec :: Vec < ethers :: core :: types :: Address > : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if tokens . len () != 5usize { return Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected " , " tokens, got " , ": "] , & match (& 5usize , & tokens . len () , & tokens) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 2 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) ; } let mut iter = tokens . into_iter () ; Ok (Self { amount_out : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_in_max : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , path : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , to : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , deadline : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , }) } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (< [_] > :: into_vec (box [self . amount_out . into_token () , self . amount_in_max . into_token () , self . path . into_token () , self . to . into_token () , self . deadline . into_token ()])) } } impl ethers :: core :: abi :: TokenizableItem for SwapTokensForExactETHCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , :: std :: vec :: Vec < ethers :: core :: types :: Address > : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { } impl ethers :: contract :: EthCall for SwapTokensForExactETHCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "swapTokensForExactETH" . into () } fn selector () -> ethers :: core :: types :: Selector { [74 , 37 , 217 , 74] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "swapTokensForExactETH(uint256,uint256,address[],address,uint256)" . into () } } impl ethers :: core :: abi :: AbiDecode for SwapTokensForExactETHCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Array (Box :: new (ethers :: core :: abi :: ParamType :: Address)) , ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize)] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for SwapTokensForExactETHCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for SwapTokensForExactETHCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_out ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_in_max ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . path ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . to ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . deadline ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; Ok (()) } } # [doc = "Container type for all input parameters for the `swapTokensForExactTokens`function with signature `swapTokensForExactTokens(uint256,uint256,address[],address,uint256)` and selector `[136, 3, 219, 238]`"] # [ethcall (name = "swapTokensForExactTokens" , abi = "swapTokensForExactTokens(uint256,uint256,address[],address,uint256)")] pub struct SwapTokensForExactTokensCall { pub amount_out : ethers :: core :: types :: U256 , pub amount_in_max : ethers :: core :: types :: U256 , pub path : :: std :: vec :: Vec < ethers :: core :: types :: Address > , pub to : ethers :: core :: types :: Address , pub deadline : ethers :: core :: types :: U256 , } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for SwapTokensForExactTokensCall { # [inline] fn clone (& self) -> SwapTokensForExactTokensCall { match * self { SwapTokensForExactTokensCall { amount_out : ref __self_0_0 , amount_in_max : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => SwapTokensForExactTokensCall { amount_out : :: core :: clone :: Clone :: clone (& (* __self_0_0)) , amount_in_max : :: core :: clone :: Clone :: clone (& (* __self_0_1)) , path : :: core :: clone :: Clone :: clone (& (* __self_0_2)) , to : :: core :: clone :: Clone :: clone (& (* __self_0_3)) , deadline : :: core :: clone :: Clone :: clone (& (* __self_0_4)) , } , } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for SwapTokensForExactTokensCall { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match * self { SwapTokensForExactTokensCall { amount_out : ref __self_0_0 , amount_in_max : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_struct (f , "SwapTokensForExactTokensCall") ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_out" , & & (* __self_0_0)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "amount_in_max" , & & (* __self_0_1)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "path" , & & (* __self_0_2)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "to" , & & (* __self_0_3)) ; let _ = :: core :: fmt :: DebugStruct :: field (debug_trait_builder , "deadline" , & & (* __self_0_4)) ; :: core :: fmt :: DebugStruct :: finish (debug_trait_builder) } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: default :: Default for SwapTokensForExactTokensCall { # [inline] fn default () -> SwapTokensForExactTokensCall { SwapTokensForExactTokensCall { amount_out : :: core :: default :: Default :: default () , amount_in_max : :: core :: default :: Default :: default () , path : :: core :: default :: Default :: default () , to : :: core :: default :: Default :: default () , deadline : :: core :: default :: Default :: default () , } } } impl :: core :: marker :: StructuralEq for SwapTokensForExactTokensCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for SwapTokensForExactTokensCall { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; let _ : :: core :: cmp :: AssertParamIsEq < :: std :: vec :: Vec < ethers :: core :: types :: Address > > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: Address > ; let _ : :: core :: cmp :: AssertParamIsEq < ethers :: core :: types :: U256 > ; } } } impl :: core :: marker :: StructuralPartialEq for SwapTokensForExactTokensCall { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for SwapTokensForExactTokensCall { # [inline] fn eq (& self , other : & SwapTokensForExactTokensCall) -> bool { match * other { SwapTokensForExactTokensCall { amount_out : ref __self_1_0 , amount_in_max : ref __self_1_1 , path : ref __self_1_2 , to : ref __self_1_3 , deadline : ref __self_1_4 } => match * self { SwapTokensForExactTokensCall { amount_out : ref __self_0_0 , amount_in_max : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => (* __self_0_0) == (* __self_1_0) && (* __self_0_1) == (* __self_1_1) && (* __self_0_2) == (* __self_1_2) && (* __self_0_3) == (* __self_1_3) && (* __self_0_4) == (* __self_1_4) , } , } } # [inline] fn ne (& self , other : & SwapTokensForExactTokensCall) -> bool { match * other { SwapTokensForExactTokensCall { amount_out : ref __self_1_0 , amount_in_max : ref __self_1_1 , path : ref __self_1_2 , to : ref __self_1_3 , deadline : ref __self_1_4 } => match * self { SwapTokensForExactTokensCall { amount_out : ref __self_0_0 , amount_in_max : ref __self_0_1 , path : ref __self_0_2 , to : ref __self_0_3 , deadline : ref __self_0_4 } => (* __self_0_0) != (* __self_1_0) || (* __self_0_1) != (* __self_1_1) || (* __self_0_2) != (* __self_1_2) || (* __self_0_3) != (* __self_1_3) || (* __self_0_4) != (* __self_1_4) , } , } } } impl ethers :: core :: abi :: AbiType for SwapTokensForExactTokensCall < > { fn param_type () -> ethers :: core :: abi :: ParamType { ethers :: core :: abi :: ParamType :: Tuple (< [_] > :: into_vec (box [< ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type () , < :: std :: vec :: Vec < ethers :: core :: types :: Address > as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: Address as ethers :: core :: abi :: AbiType > :: param_type () , < ethers :: core :: types :: U256 as ethers :: core :: abi :: AbiType > :: param_type ()])) } } impl ethers :: core :: abi :: AbiArrayType for SwapTokensForExactTokensCall < > { } impl ethers :: core :: abi :: Tokenizable for SwapTokensForExactTokensCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , :: std :: vec :: Vec < ethers :: core :: types :: Address > : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let ethers :: core :: abi :: Token :: Tuple (tokens) = token { if tokens . len () != 5usize { return Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected " , " tokens, got " , ": "] , & match (& 5usize , & tokens . len () , & tokens) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (_args . 2 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) ; } let mut iter = tokens . into_iter () ; Ok (Self { amount_out : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , amount_in_max : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , path : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , to : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , deadline : ethers :: core :: abi :: Tokenizable :: from_token (iter . next () . unwrap ()) ? , }) } else { Err (ethers :: core :: abi :: InvalidOutputType ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Expected Tuple, got "] , & match (& token ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ; res })) } } fn into_token (self) -> ethers :: core :: abi :: Token { ethers :: core :: abi :: Token :: Tuple (< [_] > :: into_vec (box [self . amount_out . into_token () , self . amount_in_max . into_token () , self . path . into_token () , self . to . into_token () , self . deadline . into_token ()])) } } impl ethers :: core :: abi :: TokenizableItem for SwapTokensForExactTokensCall < > where ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize , :: std :: vec :: Vec < ethers :: core :: types :: Address > : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: Address : ethers :: core :: abi :: Tokenize , ethers :: core :: types :: U256 : ethers :: core :: abi :: Tokenize { } impl ethers :: contract :: EthCall for SwapTokensForExactTokensCall { fn function_name () -> :: std :: borrow :: Cow < 'static , str > { "swapTokensForExactTokens" . into () } fn selector () -> ethers :: core :: types :: Selector { [136 , 3 , 219 , 238] } fn abi_signature () -> :: std :: borrow :: Cow < 'static , str > { "swapTokensForExactTokens(uint256,uint256,address[],address,uint256)" . into () } } impl ethers :: core :: abi :: AbiDecode for SwapTokensForExactTokensCall { fn decode (bytes : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { let bytes = bytes . as_ref () ; if bytes . len () < 4 || bytes [.. 4] != < Self as ethers :: contract :: EthCall > :: selector () { return Err (ethers :: contract :: AbiError :: WrongSelector) ; } let data_types = [ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Uint (256usize) , ethers :: core :: abi :: ParamType :: Array (Box :: new (ethers :: core :: abi :: ParamType :: Address)) , ethers :: core :: abi :: ParamType :: Address , ethers :: core :: abi :: ParamType :: Uint (256usize)] ; let data_tokens = ethers :: core :: abi :: decode (& data_types , & bytes [4 ..]) ? ; Ok (< Self as ethers :: core :: abi :: Tokenizable > :: from_token (ethers :: core :: abi :: Token :: Tuple (data_tokens)) ?) } } impl ethers :: core :: abi :: AbiEncode for SwapTokensForExactTokensCall { fn encode (self) -> :: std :: vec :: Vec < u8 > { let tokens = ethers :: core :: abi :: Tokenize :: into_tokens (self) ; let selector = < Self as ethers :: contract :: EthCall > :: selector () ; let encoded = ethers :: core :: abi :: encode (& tokens) ; selector . iter () . copied () . chain (encoded . into_iter ()) . collect () } } impl :: std :: fmt :: Display for SwapTokensForExactTokensCall { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_out ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . amount_in_max ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . path ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . to ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [", "] , & match () { _args => [] , })) ? ; f . write_fmt (:: core :: fmt :: Arguments :: new_v1 (& [""] , & match (& & self . deadline ,) { _args => [:: core :: fmt :: ArgumentV1 :: new (_args . 0 , :: core :: fmt :: Debug :: fmt)] , })) ? ; Ok (()) } } pub enum UniswapV2RouterCalls { Weth (WethCall) , AddLiquidity (AddLiquidityCall) , AddLiquidityETH (AddLiquidityETHCall) , Factory (FactoryCall) , GetAmountIn (GetAmountInCall) , GetAmountOut (GetAmountOutCall) , GetAmountsIn (GetAmountsInCall) , GetAmountsOut (GetAmountsOutCall) , Quote (QuoteCall) , RemoveLiquidity (RemoveLiquidityCall) , RemoveLiquidityETH (RemoveLiquidityETHCall) , RemoveLiquidityETHSupportingFeeOnTransferTokens (RemoveLiquidityETHSupportingFeeOnTransferTokensCall) , RemoveLiquidityETHWithPermit (RemoveLiquidityETHWithPermitCall) , RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokens (RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall) , RemoveLiquidityWithPermit (RemoveLiquidityWithPermitCall) , SwapETHForExactTokens (SwapETHForExactTokensCall) , SwapExactETHForTokens (SwapExactETHForTokensCall) , SwapExactETHForTokensSupportingFeeOnTransferTokens (SwapExactETHForTokensSupportingFeeOnTransferTokensCall) , SwapExactTokensForETH (SwapExactTokensForETHCall) , SwapExactTokensForETHSupportingFeeOnTransferTokens (SwapExactTokensForETHSupportingFeeOnTransferTokensCall) , SwapExactTokensForTokens (SwapExactTokensForTokensCall) , SwapExactTokensForTokensSupportingFeeOnTransferTokens (SwapExactTokensForTokensSupportingFeeOnTransferTokensCall) , SwapTokensForExactETH (SwapTokensForExactETHCall) , SwapTokensForExactTokens (SwapTokensForExactTokensCall) , } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: fmt :: Debug for UniswapV2RouterCalls { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match (& * self ,) { (& UniswapV2RouterCalls :: Weth (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "Weth") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } (& UniswapV2RouterCalls :: AddLiquidity (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "AddLiquidity") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } (& UniswapV2RouterCalls :: AddLiquidityETH (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "AddLiquidityETH") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } (& UniswapV2RouterCalls :: Factory (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "Factory") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } (& UniswapV2RouterCalls :: GetAmountIn (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "GetAmountIn") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } (& UniswapV2RouterCalls :: GetAmountOut (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "GetAmountOut") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } (& UniswapV2RouterCalls :: GetAmountsIn (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "GetAmountsIn") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } (& UniswapV2RouterCalls :: GetAmountsOut (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "GetAmountsOut") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } (& UniswapV2RouterCalls :: Quote (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "Quote") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } (& UniswapV2RouterCalls :: RemoveLiquidity (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "RemoveLiquidity") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } (& UniswapV2RouterCalls :: RemoveLiquidityETH (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "RemoveLiquidityETH") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } (& UniswapV2RouterCalls :: RemoveLiquidityETHSupportingFeeOnTransferTokens (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "RemoveLiquidityETHSupportingFeeOnTransferTokens") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } (& UniswapV2RouterCalls :: RemoveLiquidityETHWithPermit (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "RemoveLiquidityETHWithPermit") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } (& UniswapV2RouterCalls :: RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokens (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokens") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } (& UniswapV2RouterCalls :: RemoveLiquidityWithPermit (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "RemoveLiquidityWithPermit") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } (& UniswapV2RouterCalls :: SwapETHForExactTokens (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "SwapETHForExactTokens") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } (& UniswapV2RouterCalls :: SwapExactETHForTokens (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "SwapExactETHForTokens") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } (& UniswapV2RouterCalls :: SwapExactETHForTokensSupportingFeeOnTransferTokens (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "SwapExactETHForTokensSupportingFeeOnTransferTokens") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } (& UniswapV2RouterCalls :: SwapExactTokensForETH (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "SwapExactTokensForETH") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } (& UniswapV2RouterCalls :: SwapExactTokensForETHSupportingFeeOnTransferTokens (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "SwapExactTokensForETHSupportingFeeOnTransferTokens") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } (& UniswapV2RouterCalls :: SwapExactTokensForTokens (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "SwapExactTokensForTokens") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } (& UniswapV2RouterCalls :: SwapExactTokensForTokensSupportingFeeOnTransferTokens (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "SwapExactTokensForTokensSupportingFeeOnTransferTokens") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } (& UniswapV2RouterCalls :: SwapTokensForExactETH (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "SwapTokensForExactETH") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } (& UniswapV2RouterCalls :: SwapTokensForExactTokens (ref __self_0) ,) => { let debug_trait_builder = & mut :: core :: fmt :: Formatter :: debug_tuple (f , "SwapTokensForExactTokens") ; let _ = :: core :: fmt :: DebugTuple :: field (debug_trait_builder , & & (* __self_0)) ; :: core :: fmt :: DebugTuple :: finish (debug_trait_builder) } } } } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: clone :: Clone for UniswapV2RouterCalls { # [inline] fn clone (& self) -> UniswapV2RouterCalls { match (& * self ,) { (& UniswapV2RouterCalls :: Weth (ref __self_0) ,) => UniswapV2RouterCalls :: Weth (:: core :: clone :: Clone :: clone (& (* __self_0))) , (& UniswapV2RouterCalls :: AddLiquidity (ref __self_0) ,) => UniswapV2RouterCalls :: AddLiquidity (:: core :: clone :: Clone :: clone (& (* __self_0))) , (& UniswapV2RouterCalls :: AddLiquidityETH (ref __self_0) ,) => UniswapV2RouterCalls :: AddLiquidityETH (:: core :: clone :: Clone :: clone (& (* __self_0))) , (& UniswapV2RouterCalls :: Factory (ref __self_0) ,) => UniswapV2RouterCalls :: Factory (:: core :: clone :: Clone :: clone (& (* __self_0))) , (& UniswapV2RouterCalls :: GetAmountIn (ref __self_0) ,) => UniswapV2RouterCalls :: GetAmountIn (:: core :: clone :: Clone :: clone (& (* __self_0))) , (& UniswapV2RouterCalls :: GetAmountOut (ref __self_0) ,) => UniswapV2RouterCalls :: GetAmountOut (:: core :: clone :: Clone :: clone (& (* __self_0))) , (& UniswapV2RouterCalls :: GetAmountsIn (ref __self_0) ,) => UniswapV2RouterCalls :: GetAmountsIn (:: core :: clone :: Clone :: clone (& (* __self_0))) , (& UniswapV2RouterCalls :: GetAmountsOut (ref __self_0) ,) => UniswapV2RouterCalls :: GetAmountsOut (:: core :: clone :: Clone :: clone (& (* __self_0))) , (& UniswapV2RouterCalls :: Quote (ref __self_0) ,) => UniswapV2RouterCalls :: Quote (:: core :: clone :: Clone :: clone (& (* __self_0))) , (& UniswapV2RouterCalls :: RemoveLiquidity (ref __self_0) ,) => UniswapV2RouterCalls :: RemoveLiquidity (:: core :: clone :: Clone :: clone (& (* __self_0))) , (& UniswapV2RouterCalls :: RemoveLiquidityETH (ref __self_0) ,) => UniswapV2RouterCalls :: RemoveLiquidityETH (:: core :: clone :: Clone :: clone (& (* __self_0))) , (& UniswapV2RouterCalls :: RemoveLiquidityETHSupportingFeeOnTransferTokens (ref __self_0) ,) => UniswapV2RouterCalls :: RemoveLiquidityETHSupportingFeeOnTransferTokens (:: core :: clone :: Clone :: clone (& (* __self_0))) , (& UniswapV2RouterCalls :: RemoveLiquidityETHWithPermit (ref __self_0) ,) => UniswapV2RouterCalls :: RemoveLiquidityETHWithPermit (:: core :: clone :: Clone :: clone (& (* __self_0))) , (& UniswapV2RouterCalls :: RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokens (ref __self_0) ,) => UniswapV2RouterCalls :: RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokens (:: core :: clone :: Clone :: clone (& (* __self_0))) , (& UniswapV2RouterCalls :: RemoveLiquidityWithPermit (ref __self_0) ,) => UniswapV2RouterCalls :: RemoveLiquidityWithPermit (:: core :: clone :: Clone :: clone (& (* __self_0))) , (& UniswapV2RouterCalls :: SwapETHForExactTokens (ref __self_0) ,) => UniswapV2RouterCalls :: SwapETHForExactTokens (:: core :: clone :: Clone :: clone (& (* __self_0))) , (& UniswapV2RouterCalls :: SwapExactETHForTokens (ref __self_0) ,) => UniswapV2RouterCalls :: SwapExactETHForTokens (:: core :: clone :: Clone :: clone (& (* __self_0))) , (& UniswapV2RouterCalls :: SwapExactETHForTokensSupportingFeeOnTransferTokens (ref __self_0) ,) => UniswapV2RouterCalls :: SwapExactETHForTokensSupportingFeeOnTransferTokens (:: core :: clone :: Clone :: clone (& (* __self_0))) , (& UniswapV2RouterCalls :: SwapExactTokensForETH (ref __self_0) ,) => UniswapV2RouterCalls :: SwapExactTokensForETH (:: core :: clone :: Clone :: clone (& (* __self_0))) , (& UniswapV2RouterCalls :: SwapExactTokensForETHSupportingFeeOnTransferTokens (ref __self_0) ,) => UniswapV2RouterCalls :: SwapExactTokensForETHSupportingFeeOnTransferTokens (:: core :: clone :: Clone :: clone (& (* __self_0))) , (& UniswapV2RouterCalls :: SwapExactTokensForTokens (ref __self_0) ,) => UniswapV2RouterCalls :: SwapExactTokensForTokens (:: core :: clone :: Clone :: clone (& (* __self_0))) , (& UniswapV2RouterCalls :: SwapExactTokensForTokensSupportingFeeOnTransferTokens (ref __self_0) ,) => UniswapV2RouterCalls :: SwapExactTokensForTokensSupportingFeeOnTransferTokens (:: core :: clone :: Clone :: clone (& (* __self_0))) , (& UniswapV2RouterCalls :: SwapTokensForExactETH (ref __self_0) ,) => UniswapV2RouterCalls :: SwapTokensForExactETH (:: core :: clone :: Clone :: clone (& (* __self_0))) , (& UniswapV2RouterCalls :: SwapTokensForExactTokens (ref __self_0) ,) => UniswapV2RouterCalls :: SwapTokensForExactTokens (:: core :: clone :: Clone :: clone (& (* __self_0))) , } } } impl :: core :: marker :: StructuralPartialEq for UniswapV2RouterCalls { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: PartialEq for UniswapV2RouterCalls { # [inline] fn eq (& self , other : & UniswapV2RouterCalls) -> bool { { let __self_vi = :: core :: intrinsics :: discriminant_value (& * self) ; let __arg_1_vi = :: core :: intrinsics :: discriminant_value (& * other) ; if true && __self_vi == __arg_1_vi { match (& * self , & * other) { (& UniswapV2RouterCalls :: Weth (ref __self_0) , & UniswapV2RouterCalls :: Weth (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , (& UniswapV2RouterCalls :: AddLiquidity (ref __self_0) , & UniswapV2RouterCalls :: AddLiquidity (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , (& UniswapV2RouterCalls :: AddLiquidityETH (ref __self_0) , & UniswapV2RouterCalls :: AddLiquidityETH (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , (& UniswapV2RouterCalls :: Factory (ref __self_0) , & UniswapV2RouterCalls :: Factory (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , (& UniswapV2RouterCalls :: GetAmountIn (ref __self_0) , & UniswapV2RouterCalls :: GetAmountIn (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , (& UniswapV2RouterCalls :: GetAmountOut (ref __self_0) , & UniswapV2RouterCalls :: GetAmountOut (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , (& UniswapV2RouterCalls :: GetAmountsIn (ref __self_0) , & UniswapV2RouterCalls :: GetAmountsIn (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , (& UniswapV2RouterCalls :: GetAmountsOut (ref __self_0) , & UniswapV2RouterCalls :: GetAmountsOut (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , (& UniswapV2RouterCalls :: Quote (ref __self_0) , & UniswapV2RouterCalls :: Quote (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , (& UniswapV2RouterCalls :: RemoveLiquidity (ref __self_0) , & UniswapV2RouterCalls :: RemoveLiquidity (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , (& UniswapV2RouterCalls :: RemoveLiquidityETH (ref __self_0) , & UniswapV2RouterCalls :: RemoveLiquidityETH (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , (& UniswapV2RouterCalls :: RemoveLiquidityETHSupportingFeeOnTransferTokens (ref __self_0) , & UniswapV2RouterCalls :: RemoveLiquidityETHSupportingFeeOnTransferTokens (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , (& UniswapV2RouterCalls :: RemoveLiquidityETHWithPermit (ref __self_0) , & UniswapV2RouterCalls :: RemoveLiquidityETHWithPermit (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , (& UniswapV2RouterCalls :: RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokens (ref __self_0) , & UniswapV2RouterCalls :: RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokens (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , (& UniswapV2RouterCalls :: RemoveLiquidityWithPermit (ref __self_0) , & UniswapV2RouterCalls :: RemoveLiquidityWithPermit (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , (& UniswapV2RouterCalls :: SwapETHForExactTokens (ref __self_0) , & UniswapV2RouterCalls :: SwapETHForExactTokens (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , (& UniswapV2RouterCalls :: SwapExactETHForTokens (ref __self_0) , & UniswapV2RouterCalls :: SwapExactETHForTokens (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , (& UniswapV2RouterCalls :: SwapExactETHForTokensSupportingFeeOnTransferTokens (ref __self_0) , & UniswapV2RouterCalls :: SwapExactETHForTokensSupportingFeeOnTransferTokens (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , (& UniswapV2RouterCalls :: SwapExactTokensForETH (ref __self_0) , & UniswapV2RouterCalls :: SwapExactTokensForETH (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , (& UniswapV2RouterCalls :: SwapExactTokensForETHSupportingFeeOnTransferTokens (ref __self_0) , & UniswapV2RouterCalls :: SwapExactTokensForETHSupportingFeeOnTransferTokens (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , (& UniswapV2RouterCalls :: SwapExactTokensForTokens (ref __self_0) , & UniswapV2RouterCalls :: SwapExactTokensForTokens (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , (& UniswapV2RouterCalls :: SwapExactTokensForTokensSupportingFeeOnTransferTokens (ref __self_0) , & UniswapV2RouterCalls :: SwapExactTokensForTokensSupportingFeeOnTransferTokens (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , (& UniswapV2RouterCalls :: SwapTokensForExactETH (ref __self_0) , & UniswapV2RouterCalls :: SwapTokensForExactETH (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , (& UniswapV2RouterCalls :: SwapTokensForExactTokens (ref __self_0) , & UniswapV2RouterCalls :: SwapTokensForExactTokens (ref __arg_1_0)) => (* __self_0) == (* __arg_1_0) , _ => unsafe { :: core :: intrinsics :: unreachable () } } } else { false } } } # [inline] fn ne (& self , other : & UniswapV2RouterCalls) -> bool { { let __self_vi = :: core :: intrinsics :: discriminant_value (& * self) ; let __arg_1_vi = :: core :: intrinsics :: discriminant_value (& * other) ; if true && __self_vi == __arg_1_vi { match (& * self , & * other) { (& UniswapV2RouterCalls :: Weth (ref __self_0) , & UniswapV2RouterCalls :: Weth (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , (& UniswapV2RouterCalls :: AddLiquidity (ref __self_0) , & UniswapV2RouterCalls :: AddLiquidity (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , (& UniswapV2RouterCalls :: AddLiquidityETH (ref __self_0) , & UniswapV2RouterCalls :: AddLiquidityETH (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , (& UniswapV2RouterCalls :: Factory (ref __self_0) , & UniswapV2RouterCalls :: Factory (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , (& UniswapV2RouterCalls :: GetAmountIn (ref __self_0) , & UniswapV2RouterCalls :: GetAmountIn (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , (& UniswapV2RouterCalls :: GetAmountOut (ref __self_0) , & UniswapV2RouterCalls :: GetAmountOut (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , (& UniswapV2RouterCalls :: GetAmountsIn (ref __self_0) , & UniswapV2RouterCalls :: GetAmountsIn (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , (& UniswapV2RouterCalls :: GetAmountsOut (ref __self_0) , & UniswapV2RouterCalls :: GetAmountsOut (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , (& UniswapV2RouterCalls :: Quote (ref __self_0) , & UniswapV2RouterCalls :: Quote (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , (& UniswapV2RouterCalls :: RemoveLiquidity (ref __self_0) , & UniswapV2RouterCalls :: RemoveLiquidity (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , (& UniswapV2RouterCalls :: RemoveLiquidityETH (ref __self_0) , & UniswapV2RouterCalls :: RemoveLiquidityETH (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , (& UniswapV2RouterCalls :: RemoveLiquidityETHSupportingFeeOnTransferTokens (ref __self_0) , & UniswapV2RouterCalls :: RemoveLiquidityETHSupportingFeeOnTransferTokens (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , (& UniswapV2RouterCalls :: RemoveLiquidityETHWithPermit (ref __self_0) , & UniswapV2RouterCalls :: RemoveLiquidityETHWithPermit (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , (& UniswapV2RouterCalls :: RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokens (ref __self_0) , & UniswapV2RouterCalls :: RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokens (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , (& UniswapV2RouterCalls :: RemoveLiquidityWithPermit (ref __self_0) , & UniswapV2RouterCalls :: RemoveLiquidityWithPermit (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , (& UniswapV2RouterCalls :: SwapETHForExactTokens (ref __self_0) , & UniswapV2RouterCalls :: SwapETHForExactTokens (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , (& UniswapV2RouterCalls :: SwapExactETHForTokens (ref __self_0) , & UniswapV2RouterCalls :: SwapExactETHForTokens (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , (& UniswapV2RouterCalls :: SwapExactETHForTokensSupportingFeeOnTransferTokens (ref __self_0) , & UniswapV2RouterCalls :: SwapExactETHForTokensSupportingFeeOnTransferTokens (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , (& UniswapV2RouterCalls :: SwapExactTokensForETH (ref __self_0) , & UniswapV2RouterCalls :: SwapExactTokensForETH (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , (& UniswapV2RouterCalls :: SwapExactTokensForETHSupportingFeeOnTransferTokens (ref __self_0) , & UniswapV2RouterCalls :: SwapExactTokensForETHSupportingFeeOnTransferTokens (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , (& UniswapV2RouterCalls :: SwapExactTokensForTokens (ref __self_0) , & UniswapV2RouterCalls :: SwapExactTokensForTokens (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , (& UniswapV2RouterCalls :: SwapExactTokensForTokensSupportingFeeOnTransferTokens (ref __self_0) , & UniswapV2RouterCalls :: SwapExactTokensForTokensSupportingFeeOnTransferTokens (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , (& UniswapV2RouterCalls :: SwapTokensForExactETH (ref __self_0) , & UniswapV2RouterCalls :: SwapTokensForExactETH (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , (& UniswapV2RouterCalls :: SwapTokensForExactTokens (ref __self_0) , & UniswapV2RouterCalls :: SwapTokensForExactTokens (ref __arg_1_0)) => (* __self_0) != (* __arg_1_0) , _ => unsafe { :: core :: intrinsics :: unreachable () } } } else { true } } } } impl :: core :: marker :: StructuralEq for UniswapV2RouterCalls { } # [automatically_derived] # [allow (unused_qualifications)] impl :: core :: cmp :: Eq for UniswapV2RouterCalls { # [inline] # [doc (hidden)] # [no_coverage] fn assert_receiver_is_total_eq (& self) -> () { { let _ : :: core :: cmp :: AssertParamIsEq < WethCall > ; let _ : :: core :: cmp :: AssertParamIsEq < AddLiquidityCall > ; let _ : :: core :: cmp :: AssertParamIsEq < AddLiquidityETHCall > ; let _ : :: core :: cmp :: AssertParamIsEq < FactoryCall > ; let _ : :: core :: cmp :: AssertParamIsEq < GetAmountInCall > ; let _ : :: core :: cmp :: AssertParamIsEq < GetAmountOutCall > ; let _ : :: core :: cmp :: AssertParamIsEq < GetAmountsInCall > ; let _ : :: core :: cmp :: AssertParamIsEq < GetAmountsOutCall > ; let _ : :: core :: cmp :: AssertParamIsEq < QuoteCall > ; let _ : :: core :: cmp :: AssertParamIsEq < RemoveLiquidityCall > ; let _ : :: core :: cmp :: AssertParamIsEq < RemoveLiquidityETHCall > ; let _ : :: core :: cmp :: AssertParamIsEq < RemoveLiquidityETHSupportingFeeOnTransferTokensCall > ; let _ : :: core :: cmp :: AssertParamIsEq < RemoveLiquidityETHWithPermitCall > ; let _ : :: core :: cmp :: AssertParamIsEq < RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall > ; let _ : :: core :: cmp :: AssertParamIsEq < RemoveLiquidityWithPermitCall > ; let _ : :: core :: cmp :: AssertParamIsEq < SwapETHForExactTokensCall > ; let _ : :: core :: cmp :: AssertParamIsEq < SwapExactETHForTokensCall > ; let _ : :: core :: cmp :: AssertParamIsEq < SwapExactETHForTokensSupportingFeeOnTransferTokensCall > ; let _ : :: core :: cmp :: AssertParamIsEq < SwapExactTokensForETHCall > ; let _ : :: core :: cmp :: AssertParamIsEq < SwapExactTokensForETHSupportingFeeOnTransferTokensCall > ; let _ : :: core :: cmp :: AssertParamIsEq < SwapExactTokensForTokensCall > ; let _ : :: core :: cmp :: AssertParamIsEq < SwapExactTokensForTokensSupportingFeeOnTransferTokensCall > ; let _ : :: core :: cmp :: AssertParamIsEq < SwapTokensForExactETHCall > ; let _ : :: core :: cmp :: AssertParamIsEq < SwapTokensForExactTokensCall > ; } } } impl ethers :: core :: abi :: Tokenizable for UniswapV2RouterCalls { fn from_token (token : ethers :: core :: abi :: Token) -> Result < Self , ethers :: core :: abi :: InvalidOutputType > where Self : Sized { if let Ok (decoded) = WethCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: Weth (decoded)) } if let Ok (decoded) = AddLiquidityCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: AddLiquidity (decoded)) } if let Ok (decoded) = AddLiquidityETHCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: AddLiquidityETH (decoded)) } if let Ok (decoded) = FactoryCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: Factory (decoded)) } if let Ok (decoded) = GetAmountInCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: GetAmountIn (decoded)) } if let Ok (decoded) = GetAmountOutCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: GetAmountOut (decoded)) } if let Ok (decoded) = GetAmountsInCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: GetAmountsIn (decoded)) } if let Ok (decoded) = GetAmountsOutCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: GetAmountsOut (decoded)) } if let Ok (decoded) = QuoteCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: Quote (decoded)) } if let Ok (decoded) = RemoveLiquidityCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: RemoveLiquidity (decoded)) } if let Ok (decoded) = RemoveLiquidityETHCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: RemoveLiquidityETH (decoded)) } if let Ok (decoded) = RemoveLiquidityETHSupportingFeeOnTransferTokensCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: RemoveLiquidityETHSupportingFeeOnTransferTokens (decoded)) } if let Ok (decoded) = RemoveLiquidityETHWithPermitCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: RemoveLiquidityETHWithPermit (decoded)) } if let Ok (decoded) = RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokens (decoded)) } if let Ok (decoded) = RemoveLiquidityWithPermitCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: RemoveLiquidityWithPermit (decoded)) } if let Ok (decoded) = SwapETHForExactTokensCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: SwapETHForExactTokens (decoded)) } if let Ok (decoded) = SwapExactETHForTokensCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: SwapExactETHForTokens (decoded)) } if let Ok (decoded) = SwapExactETHForTokensSupportingFeeOnTransferTokensCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: SwapExactETHForTokensSupportingFeeOnTransferTokens (decoded)) } if let Ok (decoded) = SwapExactTokensForETHCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: SwapExactTokensForETH (decoded)) } if let Ok (decoded) = SwapExactTokensForETHSupportingFeeOnTransferTokensCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: SwapExactTokensForETHSupportingFeeOnTransferTokens (decoded)) } if let Ok (decoded) = SwapExactTokensForTokensCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: SwapExactTokensForTokens (decoded)) } if let Ok (decoded) = SwapExactTokensForTokensSupportingFeeOnTransferTokensCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: SwapExactTokensForTokensSupportingFeeOnTransferTokens (decoded)) } if let Ok (decoded) = SwapTokensForExactETHCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: SwapTokensForExactETH (decoded)) } if let Ok (decoded) = SwapTokensForExactTokensCall :: from_token (token . clone ()) { return Ok (UniswapV2RouterCalls :: SwapTokensForExactTokens (decoded)) } Err (ethers :: core :: abi :: InvalidOutputType ("Failed to decode all type variants" . to_string ())) } fn into_token (self) -> ethers :: core :: abi :: Token { match self { UniswapV2RouterCalls :: Weth (element) => element . into_token () , UniswapV2RouterCalls :: AddLiquidity (element) => element . into_token () , UniswapV2RouterCalls :: AddLiquidityETH (element) => element . into_token () , UniswapV2RouterCalls :: Factory (element) => element . into_token () , UniswapV2RouterCalls :: GetAmountIn (element) => element . into_token () , UniswapV2RouterCalls :: GetAmountOut (element) => element . into_token () , UniswapV2RouterCalls :: GetAmountsIn (element) => element . into_token () , UniswapV2RouterCalls :: GetAmountsOut (element) => element . into_token () , UniswapV2RouterCalls :: Quote (element) => element . into_token () , UniswapV2RouterCalls :: RemoveLiquidity (element) => element . into_token () , UniswapV2RouterCalls :: RemoveLiquidityETH (element) => element . into_token () , UniswapV2RouterCalls :: RemoveLiquidityETHSupportingFeeOnTransferTokens (element) => element . into_token () , UniswapV2RouterCalls :: RemoveLiquidityETHWithPermit (element) => element . into_token () , UniswapV2RouterCalls :: RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokens (element) => element . into_token () , UniswapV2RouterCalls :: RemoveLiquidityWithPermit (element) => element . into_token () , UniswapV2RouterCalls :: SwapETHForExactTokens (element) => element . into_token () , UniswapV2RouterCalls :: SwapExactETHForTokens (element) => element . into_token () , UniswapV2RouterCalls :: SwapExactETHForTokensSupportingFeeOnTransferTokens (element) => element . into_token () , UniswapV2RouterCalls :: SwapExactTokensForETH (element) => element . into_token () , UniswapV2RouterCalls :: SwapExactTokensForETHSupportingFeeOnTransferTokens (element) => element . into_token () , UniswapV2RouterCalls :: SwapExactTokensForTokens (element) => element . into_token () , UniswapV2RouterCalls :: SwapExactTokensForTokensSupportingFeeOnTransferTokens (element) => element . into_token () , UniswapV2RouterCalls :: SwapTokensForExactETH (element) => element . into_token () , UniswapV2RouterCalls :: SwapTokensForExactTokens (element) => element . into_token () , } } } impl ethers :: core :: abi :: TokenizableItem for UniswapV2RouterCalls { } impl ethers :: core :: abi :: AbiDecode for UniswapV2RouterCalls { fn decode (data : impl AsRef < [u8] >) -> Result < Self , ethers :: core :: abi :: AbiError > { if let Ok (decoded) = < WethCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: Weth (decoded)) } if let Ok (decoded) = < AddLiquidityCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: AddLiquidity (decoded)) } if let Ok (decoded) = < AddLiquidityETHCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: AddLiquidityETH (decoded)) } if let Ok (decoded) = < FactoryCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: Factory (decoded)) } if let Ok (decoded) = < GetAmountInCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: GetAmountIn (decoded)) } if let Ok (decoded) = < GetAmountOutCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: GetAmountOut (decoded)) } if let Ok (decoded) = < GetAmountsInCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: GetAmountsIn (decoded)) } if let Ok (decoded) = < GetAmountsOutCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: GetAmountsOut (decoded)) } if let Ok (decoded) = < QuoteCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: Quote (decoded)) } if let Ok (decoded) = < RemoveLiquidityCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: RemoveLiquidity (decoded)) } if let Ok (decoded) = < RemoveLiquidityETHCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: RemoveLiquidityETH (decoded)) } if let Ok (decoded) = < RemoveLiquidityETHSupportingFeeOnTransferTokensCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: RemoveLiquidityETHSupportingFeeOnTransferTokens (decoded)) } if let Ok (decoded) = < RemoveLiquidityETHWithPermitCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: RemoveLiquidityETHWithPermit (decoded)) } if let Ok (decoded) = < RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokens (decoded)) } if let Ok (decoded) = < RemoveLiquidityWithPermitCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: RemoveLiquidityWithPermit (decoded)) } if let Ok (decoded) = < SwapETHForExactTokensCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: SwapETHForExactTokens (decoded)) } if let Ok (decoded) = < SwapExactETHForTokensCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: SwapExactETHForTokens (decoded)) } if let Ok (decoded) = < SwapExactETHForTokensSupportingFeeOnTransferTokensCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: SwapExactETHForTokensSupportingFeeOnTransferTokens (decoded)) } if let Ok (decoded) = < SwapExactTokensForETHCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: SwapExactTokensForETH (decoded)) } if let Ok (decoded) = < SwapExactTokensForETHSupportingFeeOnTransferTokensCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: SwapExactTokensForETHSupportingFeeOnTransferTokens (decoded)) } if let Ok (decoded) = < SwapExactTokensForTokensCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: SwapExactTokensForTokens (decoded)) } if let Ok (decoded) = < SwapExactTokensForTokensSupportingFeeOnTransferTokensCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: SwapExactTokensForTokensSupportingFeeOnTransferTokens (decoded)) } if let Ok (decoded) = < SwapTokensForExactETHCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: SwapTokensForExactETH (decoded)) } if let Ok (decoded) = < SwapTokensForExactTokensCall as ethers :: core :: abi :: AbiDecode > :: decode (data . as_ref ()) { return Ok (UniswapV2RouterCalls :: SwapTokensForExactTokens (decoded)) } Err (ethers :: core :: abi :: Error :: InvalidData . into ()) } } impl ethers :: core :: abi :: AbiEncode for UniswapV2RouterCalls { fn encode (self) -> Vec < u8 > { match self { UniswapV2RouterCalls :: Weth (element) => element . encode () , UniswapV2RouterCalls :: AddLiquidity (element) => element . encode () , UniswapV2RouterCalls :: AddLiquidityETH (element) => element . encode () , UniswapV2RouterCalls :: Factory (element) => element . encode () , UniswapV2RouterCalls :: GetAmountIn (element) => element . encode () , UniswapV2RouterCalls :: GetAmountOut (element) => element . encode () , UniswapV2RouterCalls :: GetAmountsIn (element) => element . encode () , UniswapV2RouterCalls :: GetAmountsOut (element) => element . encode () , UniswapV2RouterCalls :: Quote (element) => element . encode () , UniswapV2RouterCalls :: RemoveLiquidity (element) => element . encode () , UniswapV2RouterCalls :: RemoveLiquidityETH (element) => element . encode () , UniswapV2RouterCalls :: RemoveLiquidityETHSupportingFeeOnTransferTokens (element) => element . encode () , UniswapV2RouterCalls :: RemoveLiquidityETHWithPermit (element) => element . encode () , UniswapV2RouterCalls :: RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokens (element) => element . encode () , UniswapV2RouterCalls :: RemoveLiquidityWithPermit (element) => element . encode () , UniswapV2RouterCalls :: SwapETHForExactTokens (element) => element . encode () , UniswapV2RouterCalls :: SwapExactETHForTokens (element) => element . encode () , UniswapV2RouterCalls :: SwapExactETHForTokensSupportingFeeOnTransferTokens (element) => element . encode () , UniswapV2RouterCalls :: SwapExactTokensForETH (element) => element . encode () , UniswapV2RouterCalls :: SwapExactTokensForETHSupportingFeeOnTransferTokens (element) => element . encode () , UniswapV2RouterCalls :: SwapExactTokensForTokens (element) => element . encode () , UniswapV2RouterCalls :: SwapExactTokensForTokensSupportingFeeOnTransferTokens (element) => element . encode () , UniswapV2RouterCalls :: SwapTokensForExactETH (element) => element . encode () , UniswapV2RouterCalls :: SwapTokensForExactTokens (element) => element . encode () , } } } impl :: std :: fmt :: Display for UniswapV2RouterCalls { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match self { UniswapV2RouterCalls :: Weth (element) => element . fmt (f) , UniswapV2RouterCalls :: AddLiquidity (element) => element . fmt (f) , UniswapV2RouterCalls :: AddLiquidityETH (element) => element . fmt (f) , UniswapV2RouterCalls :: Factory (element) => element . fmt (f) , UniswapV2RouterCalls :: GetAmountIn (element) => element . fmt (f) , UniswapV2RouterCalls :: GetAmountOut (element) => element . fmt (f) , UniswapV2RouterCalls :: GetAmountsIn (element) => element . fmt (f) , UniswapV2RouterCalls :: GetAmountsOut (element) => element . fmt (f) , UniswapV2RouterCalls :: Quote (element) => element . fmt (f) , UniswapV2RouterCalls :: RemoveLiquidity (element) => element . fmt (f) , UniswapV2RouterCalls :: RemoveLiquidityETH (element) => element . fmt (f) , UniswapV2RouterCalls :: RemoveLiquidityETHSupportingFeeOnTransferTokens (element) => element . fmt (f) , UniswapV2RouterCalls :: RemoveLiquidityETHWithPermit (element) => element . fmt (f) , UniswapV2RouterCalls :: RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokens (element) => element . fmt (f) , UniswapV2RouterCalls :: RemoveLiquidityWithPermit (element) => element . fmt (f) , UniswapV2RouterCalls :: SwapETHForExactTokens (element) => element . fmt (f) , UniswapV2RouterCalls :: SwapExactETHForTokens (element) => element . fmt (f) , UniswapV2RouterCalls :: SwapExactETHForTokensSupportingFeeOnTransferTokens (element) => element . fmt (f) , UniswapV2RouterCalls :: SwapExactTokensForETH (element) => element . fmt (f) , UniswapV2RouterCalls :: SwapExactTokensForETHSupportingFeeOnTransferTokens (element) => element . fmt (f) , UniswapV2RouterCalls :: SwapExactTokensForTokens (element) => element . fmt (f) , UniswapV2RouterCalls :: SwapExactTokensForTokensSupportingFeeOnTransferTokens (element) => element . fmt (f) , UniswapV2RouterCalls :: SwapTokensForExactETH (element) => element . fmt (f) , UniswapV2RouterCalls :: SwapTokensForExactTokens (element) => element . fmt (f) , } } } impl :: std :: convert :: From < WethCall > for UniswapV2RouterCalls { fn from (var : WethCall) -> Self { UniswapV2RouterCalls :: Weth (var) } } impl :: std :: convert :: From < AddLiquidityCall > for UniswapV2RouterCalls { fn from (var : AddLiquidityCall) -> Self { UniswapV2RouterCalls :: AddLiquidity (var) } } impl :: std :: convert :: From < AddLiquidityETHCall > for UniswapV2RouterCalls { fn from (var : AddLiquidityETHCall) -> Self { UniswapV2RouterCalls :: AddLiquidityETH (var) } } impl :: std :: convert :: From < FactoryCall > for UniswapV2RouterCalls { fn from (var : FactoryCall) -> Self { UniswapV2RouterCalls :: Factory (var) } } impl :: std :: convert :: From < GetAmountInCall > for UniswapV2RouterCalls { fn from (var : GetAmountInCall) -> Self { UniswapV2RouterCalls :: GetAmountIn (var) } } impl :: std :: convert :: From < GetAmountOutCall > for UniswapV2RouterCalls { fn from (var : GetAmountOutCall) -> Self { UniswapV2RouterCalls :: GetAmountOut (var) } } impl :: std :: convert :: From < GetAmountsInCall > for UniswapV2RouterCalls { fn from (var : GetAmountsInCall) -> Self { UniswapV2RouterCalls :: GetAmountsIn (var) } } impl :: std :: convert :: From < GetAmountsOutCall > for UniswapV2RouterCalls { fn from (var : GetAmountsOutCall) -> Self { UniswapV2RouterCalls :: GetAmountsOut (var) } } impl :: std :: convert :: From < QuoteCall > for UniswapV2RouterCalls { fn from (var : QuoteCall) -> Self { UniswapV2RouterCalls :: Quote (var) } } impl :: std :: convert :: From < RemoveLiquidityCall > for UniswapV2RouterCalls { fn from (var : RemoveLiquidityCall) -> Self { UniswapV2RouterCalls :: RemoveLiquidity (var) } } impl :: std :: convert :: From < RemoveLiquidityETHCall > for UniswapV2RouterCalls { fn from (var : RemoveLiquidityETHCall) -> Self { UniswapV2RouterCalls :: RemoveLiquidityETH (var) } } impl :: std :: convert :: From < RemoveLiquidityETHSupportingFeeOnTransferTokensCall > for UniswapV2RouterCalls { fn from (var : RemoveLiquidityETHSupportingFeeOnTransferTokensCall) -> Self { UniswapV2RouterCalls :: RemoveLiquidityETHSupportingFeeOnTransferTokens (var) } } impl :: std :: convert :: From < RemoveLiquidityETHWithPermitCall > for UniswapV2RouterCalls { fn from (var : RemoveLiquidityETHWithPermitCall) -> Self { UniswapV2RouterCalls :: RemoveLiquidityETHWithPermit (var) } } impl :: std :: convert :: From < RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall > for UniswapV2RouterCalls { fn from (var : RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokensCall) -> Self { UniswapV2RouterCalls :: RemoveLiquidityETHWithPermitSupportingFeeOnTransferTokens (var) } } impl :: std :: convert :: From < RemoveLiquidityWithPermitCall > for UniswapV2RouterCalls { fn from (var : RemoveLiquidityWithPermitCall) -> Self { UniswapV2RouterCalls :: RemoveLiquidityWithPermit (var) } } impl :: std :: convert :: From < SwapETHForExactTokensCall > for UniswapV2RouterCalls { fn from (var : SwapETHForExactTokensCall) -> Self { UniswapV2RouterCalls :: SwapETHForExactTokens (var) } } impl :: std :: convert :: From < SwapExactETHForTokensCall > for UniswapV2RouterCalls { fn from (var : SwapExactETHForTokensCall) -> Self { UniswapV2RouterCalls :: SwapExactETHForTokens (var) } } impl :: std :: convert :: From < SwapExactETHForTokensSupportingFeeOnTransferTokensCall > for UniswapV2RouterCalls { fn from (var : SwapExactETHForTokensSupportingFeeOnTransferTokensCall) -> Self { UniswapV2RouterCalls :: SwapExactETHForTokensSupportingFeeOnTransferTokens (var) } } impl :: std :: convert :: From < SwapExactTokensForETHCall > for UniswapV2RouterCalls { fn from (var : SwapExactTokensForETHCall) -> Self { UniswapV2RouterCalls :: SwapExactTokensForETH (var) } } impl :: std :: convert :: From < SwapExactTokensForETHSupportingFeeOnTransferTokensCall > for UniswapV2RouterCalls { fn from (var : SwapExactTokensForETHSupportingFeeOnTransferTokensCall) -> Self { UniswapV2RouterCalls :: SwapExactTokensForETHSupportingFeeOnTransferTokens (var) } } impl :: std :: convert :: From < SwapExactTokensForTokensCall > for UniswapV2RouterCalls { fn from (var : SwapExactTokensForTokensCall) -> Self { UniswapV2RouterCalls :: SwapExactTokensForTokens (var) } } impl :: std :: convert :: From < SwapExactTokensForTokensSupportingFeeOnTransferTokensCall > for UniswapV2RouterCalls { fn from (var : SwapExactTokensForTokensSupportingFeeOnTransferTokensCall) -> Self { UniswapV2RouterCalls :: SwapExactTokensForTokensSupportingFeeOnTransferTokens (var) } } impl :: std :: convert :: From < SwapTokensForExactETHCall > for UniswapV2RouterCalls { fn from (var : SwapTokensForExactETHCall) -> Self { UniswapV2RouterCalls :: SwapTokensForExactETH (var) } } impl :: std :: convert :: From < SwapTokensForExactTokensCall > for UniswapV2RouterCalls { fn from (var : SwapTokensForExactTokensCall) -> Self { UniswapV2RouterCalls :: SwapTokensForExactTokens (var) } } } uniswap_v2_router ; let ganache = Ganache :: new () . spawn () ; let addrs = ganache . addresses () . to_vec () ; let addr1 = addrs [0] ; let addr2 = addrs [1] ; let client1 = connect (& ganache , 0) ; let client2 = connect (& ganache , 1) ; };
        #[allow(clippy::expect_used)]
        tokio::runtime::Builder::new_current_thread()
            .enable_all()
            .build()
            .expect("Failed building the Runtime")
            .block_on(body);
    }
}
#[rustc_main]
pub fn main() -> () {
    extern crate test;
    test::test_main_static(&[&test_arbitrage])
}
